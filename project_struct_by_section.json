{
  "adapters": {
    "domain_adapters.py": {
      "path": "src/adapters/domain_adapters.py",
      "content": null
    },
    "pygame_renderer": {
      "UI.md": {
        "path": "src/adapters/pygame_renderer/UI.md",
        "content": "# Graphical Interface (PyGame Renderer)\n\nThis document describes the architecture, components, and usage of the **PyGame-based graphical interface** for Tactical Micro RTS.\n\n---\n\n## Overview\n\nThe PyGame renderer provides:\n- A **Main Menu** with Start, Settings, and Exit options.\n- A **Settings Screen** to configure game parameters (resolution, log level, scenarios).\n- A **Game Screen** that:\n  - Renders the battle board (adaptive size, centered).\n  - Displays units using emojis.\n  - Shows abilities menu on unit selection.\n  - Allows issuing commands (move, sprint, cast spells).\n  - Simulates ticks via a **Tick** button.\n  - Integrates with the **DomainConnector** for game logic.\n\n## Prerequisites\n\n- Python ≥ 3.11\n- [PyGame](https://www.pygame.org/) ≥ 2.0\n\n## Installation\n\n1. Clone the repository:\n   ```bash\n   git clone <repo-url>\n   cd turnshock\n   ```\n2. Create and activate a virtual environment:\n   ```bash\n   python -m venv .venv\n   source .venv/bin/activate\n   ```\n3. Install dependencies:\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n## Running\n\nLaunch the CLI entrypoint:\n```bash\nturnshock\n```\nUse the arrow keys and mouse to navigate menus:\n- **Start**: begin a new game.\n- **Settings**: adjust screen size, scenario source, log level.\n- **Exit**: quit.\n\nIn the **Game Screen**:\n1. **Select unit** by clicking on it.\n2. **Choose ability** from the bottom panel.\n3. **Click target** (cell or unit) to queue an action.\n4. Press **⏭ Tick** to advance simulation one tick.\n\n---\n\n## File Structure\n\n```\nsrc/\n└── adapters/\n    └── pygame_renderer/\n        ├── constants.py        # COLORS, DIMENSIONS, TARGET_FPS\n        ├── icons.py            # Emoji mappings for roles, effects, UI\n        ├── logger.py           # RTS_Logger configuration\n        ├── pygame_renderer.py  # Main loop, screen management\n        ├── board_renderer.py   # Adaptive board layout & rendering\n        └── screens/\n            ├── base_screen.py     # Abstract BaseScreen class\n            ├── menu_screen.py     # Main menu implementation\n            ├── settings_screen.py # Settings screen UI\n            └── game_screen.py     # In‑game screen: rendering, input, tick\n```\n\n### `pygame_renderer.py`\n\n- **PyGameRenderer**: initializes PyGame, reads `cli_settings`, manages current screen.\n- Switches between `MenuScreen`, `SettingsScreen`, and `GameScreen`.\n- Creates and passes a `DomainConnector` to the `GameScreen` for logic.\n\n### Screens\n\n- **BaseScreen**: abstract interface (`handle_event`, `update`, `draw`).\n- **MenuScreen**: buttons for Start, Settings, Exit.\n- **SettingsScreen**: input fields & save/back callbacks.\n- **GameScreen**:\n  - Renders board with `BoardRenderer`.\n  - Manages unit selection and ability menus.\n  - Queues `_pending_actions` and calls `DomainConnector.send_intents`.\n  - Draws unit statuses, action arrows, ability icons.\n\n### `BoardRenderer`\n\n- Computes adaptive cell size to occupy 80% of window height, centered with 5% top / 15% bottom margins.\n- Renders grid, obstacles, regen zones, units (with emoji).\n\n### `icons.py`\n\n- Centralized emoji definitions for unit roles, effects, abilities, and UI buttons.\n\n### Logging\n\n- Uses `RTS_Logger` from `src/config/logger.py`.\n- Each module calls `logger = RTS_Logger()` for contextual logs `[module.name]: message`.\n- Log level controlled via CLI or settings screen.\n\n### Domain Integration\n\n- **DomainConnector** (optional) wraps a separate process or in‑memory loop; here integrated directly.\n- `GameScreen` passes intents to domain, polls new `GameState`, and re‑renders.\n\n---\n\n## Customization\n\n- **Adding new abilities**: update `icons.py`, domain `base_abilities.py`, and ability logic.\n- **New screens**: subclass `BaseScreen`, register callbacks in `pygame_renderer.py`.\n- **Custom UI**: tweak colors and fonts in `constants.py`.\n- **Logging**: adjust default `cli_settings.log_level`.\n\n---\n\n## Troubleshooting\n\n- **No window appears**: ensure PyGame is installed and X11/Wayland display available.\n- **Fonts not found**: verify `FONT_PATH` in `constants.py`.\n- **Slow performance**: lower `TARGET_FPS` or reduce board size."
      },
      "__init__.py": {
        "path": "src/adapters/pygame_renderer/__init__.py",
        "content": null
      },
      "constants.py": {
        "path": "src/adapters/pygame_renderer/constants.py",
        "content": null
      },
      "icons.py": {
        "path": "src/adapters/pygame_renderer/icons.py",
        "content": null
      },
      "input_handler.py": {
        "path": "src/adapters/pygame_renderer/input_handler.py",
        "content": null
      },
      "pygame_renderer.py": {
        "path": "src/adapters/pygame_renderer/pygame_renderer.py",
        "content": null
      },
      "screens": {
        "__init__.py": {
          "path": "src/adapters/pygame_renderer/screens/__init__.py",
          "content": null
        },
        "base_screen.py": {
          "path": "src/adapters/pygame_renderer/screens/base_screen.py",
          "content": null
        },
        "board_renderer.py": {
          "path": "src/adapters/pygame_renderer/screens/board_renderer.py",
          "content": null
        },
        "game_screen.py": {
          "path": "src/adapters/pygame_renderer/screens/game_screen.py",
          "content": null
        },
        "menu_screen.py": {
          "path": "src/adapters/pygame_renderer/screens/menu_screen.py",
          "content": null
        },
        "settings_screen.py": {
          "path": "src/adapters/pygame_renderer/screens/settings_screen.py",
          "content": null
        }
      }
    }
  },
  "application": {},
  "config": {},
  "domain": {
    "README_DOMAIN.md": {
      "path": "src/domain/README_DOMAIN.md",
      "content": "# Tactical Micro RTS — Domain Layer\n\n\n```\ndomain/\n├── constants.py      # Размеры поля, количество тиков, тип TeamId\n├── enums.py          # все Enum‑ы (роли, эффекты, типы целей, типы Action)\n│\n├── geometry/         # Простые геометрические структуры\n│   └── position.py   # dataclass Position, метрики, in_bounds\n│\n├── core/             # «Данные без поведения»\n│   ├── stats.py      # UnitStats\n│   ├── ability.py    # Ability\n│   ├── effect.py     # Effect\n│   ├── board.py      # Board\n│   ├── unit.py       # HeroUnit\n│   └── state.py      # GameState\n│\n├── rules/            # Проверка законности\n│   ├── move.py       # legal_moves(), validate_move()\n│   └── ability.py    # legal_targets(), validate_ability()\n│\n├── engine/           # Исполнение симуляции\n│   ├── applier.py    # apply_ability()\n│   ├── ticker.py     # start_turn(), resolve_tick_effects()\n│   └── simulate.py   # simulate_turn()\n│\n└── heroes/           # Фабрики готовых юнитов\n    ├── base.py\n    ├── defender.py …\n```\n\n## Поток зависимостей\n\n```\ngeometry  ┐\nconstants ├─→ core ─→ rules ─→ engine\nenums     ┘\nheroes ─────────┘       (только к core)\n```\n\n# RTS Game Rules (Tick-based)\n\n## 1. Game Map\n- Игровое поле: квадратная сетка (по умолчанию 13x13)\n- Препятствия: нельзя пройти/стрелять сквозь\n- Зоны: баффы/реген\n\n## 2. Units\n- Каждый персонаж — отдельная сущность\n- Может быть живым или мертвым\n\n## 3. Tick Loop\n\nКаждый тик:\n1. **Обновление эффектов:**  \n    - У каждого юнита декрементируется duration всех активных эффектов\n    - Эффекты с duration=0 исчезают\n2. **Выполнение действий:**  \n    - Каждый живой юнит получает возможность сделать 1 действие (move/attack/use ability)\n    - Если действие невозможно — оно игнорируется\n    - Коллизии (например, два юнита хотят одну клетку): оба остаются на месте/оба fail\n3. **Применение эффектов клеток:**  \n    - Например, регенерация\n4. **Проверка конца игры:**  \n    - Если команда полностью уничтожена — конец игры\n    \nИнтерфейсы (CLI/React/Gym) используют только  \n`domain.engine.simulate_turn()` и фабрики из `domain.heroes`."
    },
    "__init__.py": {
      "path": "src/domain/__init__.py",
      "content": null
    },
    "constants.py": {
      "path": "src/domain/constants.py",
      "content": null
    },
    "enums.py": {
      "path": "src/domain/enums.py",
      "content": null
    },
    "errors.py": {
      "path": "src/domain/errors.py",
      "content": null
    },
    "heroes": {
      "README.md": {
        "path": "src/domain/heroes/README.md",
        "content": "# Пакет `heroes`\n\nСодержит фабрики `create_*` и заготовки способностей.  \nНе импортирует `rules` или `engine` — только `core`."
      },
      "archer_profile.py": {
        "path": "src/domain/heroes/archer_profile.py",
        "content": null
      },
      "base_abilities.py": {
        "path": "src/domain/heroes/base_abilities.py",
        "content": null
      },
      "defender_profile.py": {
        "path": "src/domain/heroes/defender_profile.py",
        "content": null
      },
      "mage_dps_profile.py": {
        "path": "src/domain/heroes/mage_dps_profile.py",
        "content": null
      },
      "mage_supp_profile.py": {
        "path": "src/domain/heroes/mage_supp_profile.py",
        "content": null
      },
      "profile.py": {
        "path": "src/domain/heroes/profile.py",
        "content": null
      },
      "swordsman_profile.py": {
        "path": "src/domain/heroes/swordsman_profile.py",
        "content": null
      }
    },
    "engine": {
      "__init__.py": {
        "path": "src/domain/engine/__init__.py",
        "content": null
      },
      "ability_utils.py": {
        "path": "src/domain/engine/ability_utils.py",
        "content": null
      },
      "applier.py": {
        "path": "src/domain/engine/applier.py",
        "content": null
      },
      "combat.py": {
        "path": "src/domain/engine/combat.py",
        "content": null
      },
      "engine.md": {
        "path": "src/domain/engine/engine.md",
        "content": "# 🧠 `domain.engine/` — Логика симуляции боя\n\nМодуль `domain.engine` содержит **ядро симуляции игрового процесса по тиковой модели**.  \nОн отвечает за:\n\n- прогресс тика (`event_tick`)\n- применение способностей (`apply_ability`)\n- расчет эффектов (`damage`, `heal`, `effects`)\n- выбор целей (`chain targeting`)\n- запись боевой статистики (`stats_tracker`)\n\n---\n\n## 🔁 `event_loop.py` — главный цикл симуляции\n\nФункция `event_tick(state, intents)`:\n\n1. **Обновляет эффекты** (уменьшает длительность).\n2. **Применяет регенерацию зоны** (regen_zone).\n3. **Восстанавливает AP**.\n4. **Выполняет действия юнитов**:\n   - если идет каст → продолжаем\n   - если пришел новый интент → прерываем и заменяем\n   - иначе продолжаем текущее (движение/ожидание)\n\n**Если способность завершается и содержит эффекты** — она передается в `apply_ability`.\n\n---\n\n## ✨ `applier.py` — применение способностей\n\nФункция `apply_ability(...)`:\n- фиксирует использование в `stats_tracker`\n- выбирает цели (учитывая AoE)\n- применяет каждый `Effect`:\n  - `DAMAGE` → `apply_damage_to_unit`\n  - `HEAL` → `apply_heal_to_unit`\n  - `BUFF/DEBUFF/SHIELD` → `add_effect_to_unit`\n\n---\n\n## 🔗 `ability_utils.py` — выбор целей\n\n- `select_chain_targets(...)` — для цепных заклинаний:\n  выбирает до N ближайших целей в радиусе от центра.\n\n---\n\n## 🧪 `combat.py` — примитивы урона/хила\n\n- `calculate_damage()` — учитывает все BUFF-эффекты.\n- `apply_damage_to_unit()` — урон с учетом щита.\n- `apply_heal_to_unit()` — хил до max_hp.\n- `add_effect_to_unit()` — навешивает эффект.\n\n---\n\n## 🧩 Взаимосвязи:\n\n- `event_loop` вызывает `apply_ability`\n- `apply_ability` вызывает `combat` и `stats`\n- Все работает с `GameState` и `HeroUnit`\n\n---\n\n## 💡 Пример использования:\n\n```python\nstate, executed, done = event_tick(state, intents)\n```\n\n---\n\n## 📌 Где логика НЕ живет:\n- Никаких проверок условий/AI — только исполнение.\n- Все проверки (LoS, range) должны быть сделаны до передачи `intent`."
      },
      "event_loop.py": {
        "path": "src/domain/engine/event_loop.py",
        "content": null
      }
    },
    "factory": {
      "game_factory.py": {
        "path": "src/domain/factory/game_factory.py",
        "content": null
      },
      "unit_factory.py": {
        "path": "src/domain/factory/unit_factory.py",
        "content": null
      }
    },
    "analytics": {
      "analytics.md": {
        "path": "src/domain/analytics/analytics.md",
        "content": "# 📊 Domain Analytics\n\nПапка `src/domain/analytics` отвечает за сбор и хранение статистики игры на уровне домена:\n- сколько раз каждый юнит использовал каждую способность;\n- сколько урона он нанёс врагам и союзникам;\n- сколько исцелил;\n- какие эффекты наложил и в каком количестве.\n\nВ этой папке находится единственный модуль:\n\n---\n\n## stats.py\n\n```python\nfrom dataclasses import dataclass, field\nfrom typing import Dict\nfrom ..core.effect import EffectType\n\n@dataclass\nclass AbilityStats:\n    uses: int = 0\n    damage_to_enemies: int = 0\n    damage_to_allies: int = 0\n    healing: int = 0\n    effects_applied: Dict[EffectType, int] = field(default_factory=dict)\n\n@dataclass\nclass UnitStats:\n    by_ability: Dict[str, AbilityStats] = field(default_factory=dict)\n\nclass StatsTracker:\n    \"\"\"\n    Собирает per-tick и итоговую статистику по каждому юниту:\n      - record_use       — фиксирует использование способности\n      - record_damage    — фиксирует сколько урона нанесено и кому (враг/союзник)\n      - record_heal      — фиксирует сколько исцелено\n      - record_effect    — фиксирует, сколько и каких эффектов наложено\n      - get_stats        — возвращает итоговую статистику по всем юнитам\n      - reset            — очищает накопленные данные\n    \"\"\"\n    def __init__(self):\n        self.units: Dict[int, UnitStats] = {}\n\n    def _get_ability_stats(self, caster_id: int, ability_name: str) -> AbilityStats:\n\n    def record_use(self, caster_id: int, ability_name: str) -> None:\n\n    def record_damage(self, caster_id: int, ability_name: str, amount: int, enemy: bool) -> None:\n\n    def record_heal(self, caster_id: int, ability_name: str, amount: int) -> None:\n    \n    def record_effect(self, caster_id: int, ability_name: str, eff_type: EffectType, amount: int) -> None:\n\n    def get_stats(self) -> Dict[int, UnitStats]:\n\n    def reset(self) -> None:\n        \n\n# глобальный трекер, доступный во всём домене\nstats_tracker = StatsTracker()\nКак это работает\nИнтеграция в домен\nВ функции apply_ability (в domain/engine/applier.py) после каждого применения способности вызываются методы stats_tracker.record_*, чтобы зафиксировать:\n\nфакт использования (record_use),\n\nпринесённый урон (record_damage),\n\nотхил (record_heal),\n\nнакладываемые эффекты (record_effect).\n\nСбор и хранение\nStatsTracker хранит в поле units словарь:\n\npython\n\n{\n  unit_id: UnitStats(by_ability={\n    \"fireball\": AbilityStats(...),\n    \"move_to\":  AbilityStats(...),\n    ...\n  }),\n  ...\n}\nПолучение результатов\nВ любой момент (например, после завершения всех тиков) можно вызвать:\n\npython\nCopy\nEdit\nfrom domain.analytics.stats import stats_tracker\nfinal_stats = stats_tracker.get_stats()\nи получить подробную разбивку по каждому юниту и каждой способности.\n\nСброс\nЕсли нужно начать новый матч или тест, вызываем stats_tracker.reset(), чтобы очистить все старые данные.\n\nПример использования\n\n# ... в начале игры\nstats_tracker.reset()\n\n# во время игры — всё происходит автоматически внутри apply_ability\n\n# в конце игры\nfor unit_id, u_stats in stats_tracker.get_stats().items():\n    print(f\"Юнит {unit_id}:\")\n    for ability_name, ab in u_stats.by_ability.items():\n        print(f\"  {ability_name}: использовано {ab.uses} раз, \"\n              f\"урон врагам={ab.damage_to_enemies}, урон союзникам={ab.damage_to_allies}, \"\n              f\"лечение={ab.healing}, эффекты={ab.effects_applied}\")\n\nДанный модуль позволяет аналитикам и разработчикам быстро получать метрики по балансу способностей и поведению юнитов без изменения основной логики симуляции."
      },
      "stats.py": {
        "path": "src/domain/analytics/stats.py",
        "content": null
      }
    },
    "core": {
      "__init__.py": {
        "path": "src/domain/core/__init__.py",
        "content": null
      },
      "ability.py": {
        "path": "src/domain/core/ability.py",
        "content": null
      },
      "action.py": {
        "path": "src/domain/core/action.py",
        "content": null
      },
      "board.py": {
        "path": "src/domain/core/board.py",
        "content": null
      },
      "core.md": {
        "path": "src/domain/core/core.md",
        "content": "# 🧩 Domain Core Overview\n\n**`src/domain/core/`** — фундаментальный слой доменной модели, отвечающий за представление всех ключевых сущностей игровой логики: способностей, эффектов, доски, состояния игры и активных действий.\n\n---\n\n## Модули и классы\n\n### 1. `ability.py` — **Способности (Abilities)**\n\n```python\n@dataclass(frozen=True, slots=True)\nclass Ability:\n    name: str                # Уникальный идентификатор (например, \"fireball\")\n    range: int               # Дальность применения\n    cost: int                # Стоимость в AP\n    target: TargetType       # Тип цели: SELF, ENEMY, ALLY и др.\n    effects: FrozenSet[Effect]  # Набор эффектов, которые накладывает абилка\n    cast_time: int = 1       # Сколько тиков длится применение\n    aoe: int = 0             # Радиус действия (0 — одноцелевая)\n    bounces: int = 0         # Количество \"прыжков\" (для цепных умений)\n    bounce_mult: float = 1.0 # Множитель силы прыжка\nНазначение:\nОписание полной информации о способности (например, \"melee_attack\", \"move_to\", \"fireball\"). Абилка содержит все параметры для симуляции применения.\n\n2. action.py — Активные действия (Active Actions)\npython\nCopy\nEdit\n@dataclass\nclass ActiveAction:\n    ability: Ability\n    target: Position\n    ticks_remaining: int\n    path: Optional[List[Position]] = None\n    target_unit_id: Optional[int] = None\n    started: bool = False\n\n    def tick(self) -> bool:\n        self.ticks_remaining -= 1\n        return self.ticks_remaining <= 0\nНазначение:\nХранит текущее \"происходящее\" действие юнита: какую способность он кастует, по какой цели, сколько тиков осталось, какой путь идёт (для движения), начато ли применение.\nИспользуется для поэтапного исполнения сложных действий (движение, длительные касты).\n\n3. board.py — Игровое поле (Board)\npython\nCopy\nEdit\n@dataclass(slots=True)\nclass Board:\n    obstacles: Set[Position] = field(default_factory=set)\n    regen_zone: Set[Position] = field(default_factory=set)\n\n    def is_blocked(self, pos: Position) -> bool\n    def is_line_blocked(self, a: Position, b: Position) -> bool\n    def apply_zone_effects(self, state: 'GameState') -> None\nНазначение:\nПредставляет карту уровня:\n\nobstacles — клетки-стены, по которым нельзя пройти/прострелить.\n\nregen_zone — клетки, на которых восстанавливается HP.\n\nМетоды для проверки, можно ли пройти/прострелить между двумя точками, и применения зональных эффектов.\n\n4. effect.py — Эффекты (Effects)\npython\nCopy\nEdit\n@dataclass(frozen=True, slots=True)\nclass Effect:\n    type: EffectType    # Тип эффекта (DAMAGE, HEAL, SHIELD и др.)\n    value: int          # Значение (сколько HP лечит/снимает, сила щита и др.)\n    duration: int       # Длительность (в тиках)\nНазначение:\nКласс для представления одного эффекта (урон, щит, замедление и др.), который накладывается абилкой на цель.\n\n5. state.py — Состояние игры (GameState)\npython\nCopy\nEdit\n@dataclass(slots=True)\nclass GameState:\n    tick: int\n    units: Dict[int, HeroUnit]\n    board: Board\n\n    def clear_temporary(self) -> None\n    def get_unit_at(self, pos)\n    def is_game_over(self) -> bool\nНазначение:\n\nПредставляет всю игровую \"картину\": кто жив, кто где стоит, какие препятствия.\n\nХранит все юниты (units) и игровую доску (board).\n\nМетоды для быстрого доступа к юниту по позиции и проверки конца игры.\n\nВзаимосвязи\nAbility используется в ActiveAction (какую способность кастует юнит).\n\nEffect хранится внутри Ability (что произойдёт при касте).\n\nBoard и GameState отвечают за состояние поля и объектов.\n\nGameState содержит все юниты (HeroUnit) и доску (Board).\n\nActiveAction (у юнита) — ключевой для симуляции механизм \"что сейчас делает юнит\".\n\nДля чего использовать эти классы?\nAbility — когда нужно определить, как работает та или иная способность.\n\nActiveAction — если требуется знать, что сейчас делает юнит и сколько времени осталось.\n\nBoard — для проверки, можно ли ходить/стрелять по клетке.\n\nEffect — чтобы навесить/снять эффекты с персонажа.\n\nGameState — основная точка для доступа к состоянию игры в любом тике.\n\nВсе эти классы не содержат логики исполнения (кроме методов доступа и простых операций) и образуют чистую, независимую доменную модель. Вся \"магия\" симуляции происходит в engine — эти классы лишь её описывают.\n\n# 📦 src/domain/core — Модель юнита и статы\n\n## Модуль `unit_stats.py`\nОпределяет базовые характеристики любого юнита (не игровое состояние, а \"паспорт\"):\n\n```python\n@dataclass(frozen=True, slots=True)\nclass UnitStats:\n    \"\"\"\n    Базовые характеристики юнита:\n      - hp_max       — максимальное здоровье\n      - move_range   — сколько клеток может пройти за 1 AP\n      - block_chance — шанс заблокировать часть урона (0-100%)\n      - max_ap       — сколько AP сбрасывается в начале хода\n    \"\"\"\n    hp_max: int\n    move_range: int = 1\n    block_chance: int = 0\n    max_ap: int = MAX_AP\nИспользуется в профиле героя, чтобы быстро и централизованно описывать все \"постоянные\" параметры юнита.\n\nМодуль unit.py\nЯдро модели игрового персонажа: HeroUnit.\n\nОсновные аспекты:\nХранит динамическое состояние юнита (HP, AP, позиция, эффекты, текущее действие).\n\nПоддерживает работу с \"боевыми\" операциями через combat-модуль.\n\nРеализует логику старта и исполнения текущего действия с автоповтором.\n\nАвтоматически заново ставит действие после исполнения (до override).\n\nРаботает с pathfinding для движения.\n\nИспользует декомпозицию: урон, лечение, эффекты — в combat.\n\npython\nCopy\nEdit\n@dataclass(slots=True)\nclass HeroUnit:\n    id: int\n    role: UnitRole\n    team: TeamId\n    pos: Position\n    profile: CharacterProfile\n    hp: int = field(init=False)\n    ap: int = field(init=False)\n    effects: list[Effect] = field(default_factory=list, init=False)\n    current_action: Optional[ActiveAction] = field(default=None, init=False)\n    ...\nКлючевые методы:\ntick_effects — уменьшает длительность эффектов, удаляя истёкшие.\n\napply_ap_regen — восстанавливает AP по профилю.\n\napply_damage/apply_heal/add_effect — быстрый доступ к боевым операциям (делегирует combat-модулю).\n\nstart_action — начинает новое действие (если не кастует что-то).\n\nadvance_action — реализует основной жизненный цикл: движение, касты, повтор.\n\nТипичные сценарии использования:\nUnitStats — когда надо получить/задать базовые параметры, не зависящие от состояния боя.\n\nHeroUnit — всегда при обращении к игровому юниту в GameState.\n\nОтличие:\nUnitStats — неизменяемый набор характеристик (\"профиль\" юнита, аналог D&D stat block).\n\nHeroUnit — динамическое, изменяемое состояние юнита на карте (HP, AP, эффекты, позиция, текущее действие).\n\nВажные замечания:\nБоевая логика максимально выведена в combat-модуль для разделения ответственности.\n\nВсе действия юнита (каст, движение, ожидание) должны идти только через advance_action.\n\ncurrent_action автоматически повторяется, пока не будет перезаписано новым интентом."
      },
      "effect.py": {
        "path": "src/domain/core/effect.py",
        "content": null
      },
      "state.py": {
        "path": "src/domain/core/state.py",
        "content": null
      },
      "stats.py": {
        "path": "src/domain/core/stats.py",
        "content": null
      },
      "unit.py": {
        "path": "src/domain/core/unit.py",
        "content": null
      }
    },
    "geometry": {
      "README.md": {
        "path": "src/domain/geometry/README.md",
        "content": ""
      },
      "__init__.py": {
        "path": "src/domain/geometry/__init__.py",
        "content": null
      },
      "pathfinding.py": {
        "path": "src/domain/geometry/pathfinding.py",
        "content": null
      },
      "position.py": {
        "path": "src/domain/geometry/position.py",
        "content": null
      }
    },
    "rules": {
      "README.md": {
        "path": "src/domain/rules/README.md",
        "content": "# Пакет `rules`\n\nПроверка легальности движений/умений + генераторы.\n\n| Файл          | Задача |\n|---------------|-------|\n| `move.py`     | `legal_moves`, `validate_move` |\n| `ability.py`  | `legal_targets`, `validate_ability` |"
      },
      "__init__.py": {
        "path": "src/domain/rules/__init__.py",
        "content": null
      },
      "ability.py": {
        "path": "src/domain/rules/ability.py",
        "content": null
      },
      "move.py": {
        "path": "src/domain/rules/move.py",
        "content": null
      }
    }
  },
  "interfaces": {}
}