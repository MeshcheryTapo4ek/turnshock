{
  "application": {
    "__init__.py": {
      "path": "src/application/__init__.py",
      "content": ""
    },
    "game_generator.py": {
      "path": "src/application/game_generator.py",
      "content": "# relative path: src/application/game_generator.py\n\nimport random\nfrom pathlib import Path\nfrom typing import Iterator, Callable, Optional, List\n\nfrom config.config_loader import load_map_config, load_hero_setup\nfrom config.cli_config import cli_settings\nfrom domain.factory.game_factory import build_new_game\n\n\nclass GeneratorConfig:\n    \"\"\"\n    –ö–æ–Ω—Ñ–∏–≥ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –∏–≥—Ä:\n      - scenarios_dir: –ø–∞–ø–∫–∞ —Å –ø–æ–¥–ø–∞–ø–∫–∞–º–∏-—Å—Ü–µ–Ω–∞—Ä–∏—è–º–∏\n      - mode: \"sequential\" –∏–ª–∏ \"random\"\n      - loop: –∑–∞—Ü–∏–∫–ª–∏—Ç—å –ª–∏ –ø–æ—Å–ª–µ –∫–æ–Ω—Ü–∞\n      - filter_fn: –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä –ø–æ –∏–º–µ–Ω–∏ —Å—Ü–µ–Ω–∞—Ä–∏—è\n    \"\"\"\n    def __init__(\n        self,\n        scenarios_dir: Path,\n        mode: str = \"sequential\",\n        loop: bool = True,\n        filter_fn: Optional[Callable[[str], bool]] = None\n    ):\n        self.scenarios_dir = scenarios_dir\n        self.mode = mode\n        self.loop = loop\n        self.filter_fn = filter_fn\n\ndef build_generator_config_from_cli() -> GeneratorConfig:\n    \"\"\"\n    –°—Ç—Ä–æ–∏—Ç GeneratorConfig –ø–æ –∑–Ω–∞—á–µ–Ω–∏—è–º –∏–∑ cli_settings:\n      - scenarios_dir, mode, loop\n      - count –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –≤ generate_games()\n      - filter_fn ‚Äî –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω scenario_name, —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –µ–≥–æ\n    \"\"\"\n    filter_fn: Optional[Callable[[str], bool]] = None\n    if cli_settings.scenario_name:\n        name = cli_settings.scenario_name\n        filter_fn = lambda n: n == name\n\n    return GeneratorConfig(\n        scenarios_dir=Path(cli_settings.scenarios_dir),\n        mode=cli_settings.mode,\n        loop=cli_settings.loop,\n        filter_fn=filter_fn\n    )\n\n\ndef generate_games(\n    cfg: GeneratorConfig,\n    count: int = -1\n) -> Iterator:\n    \"\"\"\n    –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–¥–∞—ë—Ç –¥–æ `count` GameState:\n      - –µ—Å–ª–∏ count > 0 ‚Äî —Ä–æ–≤–Ω–æ count –∏–≥—Ä, –ø–æ—Ç–æ–º StopIteration\n      - –µ—Å–ª–∏ count < 0 ‚Äî –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ (–ø—Ä–∏ loop=True) –∏–ª–∏ –¥–æ –ø–µ—Ä–≤–æ–≥–æ —Ü–∏–∫–ª–∞ (loop=False)\n    \"\"\"\n    # —Å–æ–±–∏—Ä–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–º—ë–Ω —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤\n    names: List[str] = [\n        p.name\n        for p in cfg.scenarios_dir.iterdir()\n        if p.is_dir()\n    ]\n    if cfg.filter_fn:\n        names = [n for n in names if cfg.filter_fn(n)]\n    if cfg.mode == \"random\":\n        random.shuffle(names)\n\n    yielded = 0\n    first_pass = True\n    while (count < 0 and (first_pass or cfg.loop)) or (count >= 0 and yielded < count):\n        first_pass = False\n        for name in names:\n            if count >= 0 and yielded >= count:\n                return\n\n            base = cfg.scenarios_dir / name\n            map_cfg    = load_map_config(str(base / \"map.json\"))\n            heroes_cfg = load_hero_setup(str(base / \"heroes.json\"))\n\n            state = build_new_game(\n                tick=0,\n                hero_setup=heroes_cfg,\n                obstacles=map_cfg.obstacles,\n                regen_zone=map_cfg.regen_zone,\n            )\n            yield state\n            yielded += 1\n\n        if cfg.mode == \"random\":\n            random.shuffle(names)\n        if count >= 0 and yielded >= count:\n            return\n        if not cfg.loop:\n            return\n"
    },
    "services": {
      "domain_connector.py": {
        "path": "src/application/services/domain_connector.py",
        "content": "# src/adapters/domain_adapter.py\n\nfrom application.game_generator import build_generator_config_from_cli, generate_games\nfrom domain.engine.event_loop import event_tick\nfrom domain.analytics.stats import stats_tracker\n\n\nclass DomainConnector:\n    def __init__(self):\n        self._create_new_game()\n\n    def _create_new_game(self):\n        gen_cfg = build_generator_config_from_cli()\n        gen_iter = generate_games(gen_cfg, count=1)\n        self.state = next(gen_iter)\n\n    def send_intents(self, intents: dict):\n        \n        self.state, executed, is_over = event_tick(self.state, intents)\n        if is_over:\n            \n            final_stats = stats_tracker.get_stats()\n            for unit_id, u_stats in final_stats.items():\n\n                print(f\"=== Unit {unit_id} stats ===\")\n\n                for ability, ab in u_stats.by_ability.items():\n\n                    print(f\" {ability}: used {ab.uses}x, \"\n                        f\"damage‚Üíenemies={ab.damage_to_enemies}, allies={ab.damage_to_allies}, \"\n                        f\"healed={ab.healing}, effects={ab.effects_applied}\")\n            \n            stats_tracker.reset()\n            \n            self._create_new_game()\n        return executed\n\n    def get_state(self):\n        return self.state\n"
      }
    }
  },
  "config": {},
  "domain": {
    "README_DOMAIN.md": {
      "path": "src/domain/README_DOMAIN.md",
      "content": "# Tactical Micro¬†RTS ‚Äî Domain Layer\n\n\n```\ndomain/\n‚îú‚îÄ‚îÄ constants.py      # –†–∞–∑–º–µ—Ä—ã –ø–æ–ª—è, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–∏–∫–æ–≤, —Ç–∏–ø TeamId\n‚îú‚îÄ‚îÄ enums.py          # –≤—Å–µ Enum‚Äë—ã (—Ä–æ–ª–∏, —ç—Ñ—Ñ–µ–∫—Ç—ã, —Ç–∏–ø—ã —Ü–µ–ª–µ–π, —Ç–∏–ø—ã Action)\n‚îÇ\n‚îú‚îÄ‚îÄ geometry/         # –ü—Ä–æ—Å—Ç—ã–µ –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã\n‚îÇ   ‚îî‚îÄ‚îÄ position.py   # dataclass Position, –º–µ—Ç—Ä–∏–∫–∏, in_bounds\n‚îÇ\n‚îú‚îÄ‚îÄ core/             # ¬´–î–∞–Ω–Ω—ã–µ –±–µ–∑ –ø–æ–≤–µ–¥–µ–Ω–∏—è¬ª\n‚îÇ   ‚îú‚îÄ‚îÄ stats.py      # UnitStats\n‚îÇ   ‚îú‚îÄ‚îÄ ability.py    # Ability\n‚îÇ   ‚îú‚îÄ‚îÄ effect.py     # Effect\n‚îÇ   ‚îú‚îÄ‚îÄ board.py      # Board\n‚îÇ   ‚îú‚îÄ‚îÄ unit.py       # HeroUnit\n‚îÇ   ‚îî‚îÄ‚îÄ state.py      # GameState\n‚îÇ\n‚îú‚îÄ‚îÄ rules/            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫–æ–Ω–Ω–æ—Å—Ç–∏\n‚îÇ   ‚îú‚îÄ‚îÄ move.py       # legal_moves(), validate_move()\n‚îÇ   ‚îî‚îÄ‚îÄ ability.py    # legal_targets(), validate_ability()\n‚îÇ\n‚îú‚îÄ‚îÄ engine/           # –ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–∏–º—É–ª—è—Ü–∏–∏\n‚îÇ   ‚îú‚îÄ‚îÄ applier.py    # apply_ability()\n‚îÇ   ‚îú‚îÄ‚îÄ ticker.py     # start_turn(), resolve_tick_effects()\n‚îÇ   ‚îî‚îÄ‚îÄ simulate.py   # simulate_turn()\n‚îÇ\n‚îî‚îÄ‚îÄ heroes/           # –§–∞–±—Ä–∏–∫–∏ –≥–æ—Ç–æ–≤—ã—Ö —é–Ω–∏—Ç–æ–≤\n    ‚îú‚îÄ‚îÄ base.py\n    ‚îú‚îÄ‚îÄ defender.py ‚Ä¶\n```\n\n## –ü–æ—Ç–æ–∫ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π\n\n```\ngeometry  ‚îê\nconstants ‚îú‚îÄ‚Üí core ‚îÄ‚Üí rules ‚îÄ‚Üí engine\nenums     ‚îò\nheroes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       (—Ç–æ–ª—å–∫–æ –∫ core)\n```\n\n# RTS Game Rules (Tick-based)\n\n## 1. Game Map\n- –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ: –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è —Å–µ—Ç–∫–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 13x13)\n- –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è: –Ω–µ–ª—å–∑—è –ø—Ä–æ–π—Ç–∏/—Å—Ç—Ä–µ–ª—è—Ç—å —Å–∫–≤–æ–∑—å\n- –ó–æ–Ω—ã: –±–∞—Ñ—Ñ—ã/—Ä–µ–≥–µ–Ω\n\n## 2. Units\n- –ö–∞–∂–¥—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂ ‚Äî –æ—Ç–¥–µ–ª—å–Ω–∞—è —Å—É—â–Ω–æ—Å—Ç—å\n- –ú–æ–∂–µ—Ç –±—ã—Ç—å –∂–∏–≤—ã–º –∏–ª–∏ –º–µ—Ä—Ç–≤—ã–º\n\n## 3. Tick Loop\n\n–ö–∞–∂–¥—ã–π —Ç–∏–∫:\n1. **–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤:**  \n    - –£ –∫–∞–∂–¥–æ–≥–æ —é–Ω–∏—Ç–∞ –¥–µ–∫—Ä–µ–º–µ–Ω—Ç–∏—Ä—É–µ—Ç—Å—è duration –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤\n    - –≠—Ñ—Ñ–µ–∫—Ç—ã —Å duration=0 –∏—Å—á–µ–∑–∞—é—Ç\n2. **–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏–π:**  \n    - –ö–∞–∂–¥—ã–π –∂–∏–≤–æ–π —é–Ω–∏—Ç –ø–æ–ª—É—á–∞–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–¥–µ–ª–∞—Ç—å 1 –¥–µ–π—Å—Ç–≤–∏–µ (move/attack/use ability)\n    - –ï—Å–ª–∏ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ ‚Äî –æ–Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç—Å—è\n    - –ö–æ–ª–ª–∏–∑–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–≤–∞ —é–Ω–∏—Ç–∞ —Ö–æ—Ç—è—Ç –æ–¥–Ω—É –∫–ª–µ—Ç–∫—É): –æ–±–∞ –æ—Å—Ç–∞—é—Ç—Å—è –Ω–∞ –º–µ—Å—Ç–µ/–æ–±–∞ fail\n3. **–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –∫–ª–µ—Ç–æ–∫:**  \n    - –ù–∞–ø—Ä–∏–º–µ—Ä, —Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n4. **–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã:**  \n    - –ï—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∞ ‚Äî –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã\n    \n–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã (CLI/React/Gym) –∏—Å–ø–æ–ª—å–∑—É—é—Ç —Ç–æ–ª—å–∫–æ  \n`domain.engine.simulate_turn()` –∏ —Ñ–∞–±—Ä–∏–∫–∏ –∏–∑ `domain.heroes`."
    },
    "__init__.py": {
      "path": "src/domain/__init__.py",
      "content": "            \n"
    },
    "constants.py": {
      "path": "src/domain/constants.py",
      "content": "from typing import Final\nfrom typing import Literal\n\nTeamId = Literal[\"A\", \"B\"]\n\nBOARD_SIZE: Final = 13\nTICKS_PER_TURN: Final = 16\nMAX_AP: Final = 16\n"
    },
    "enums.py": {
      "path": "src/domain/enums.py",
      "content": "from enum import Enum, auto\n\nclass UnitRole(Enum):\n    SWORDSMAN = auto(); SHIELD = auto(); ASSASSIN = auto()\n    ARCHER = auto(); MAGE_DPS = auto(); MAGE_SUPP = auto()\n    BARD = auto()\n\nclass EffectType(Enum):\n    DAMAGE = auto(); HEAL = auto()\n    BUFF = auto(); DEBUFF = auto()\n    SLOW_AP = auto(); AP_BOOST = auto()\n    DODGE = auto(); TAUNT = auto()\n    SHIELD = auto(); BLIND = auto()\n    BOUNCE = auto(); FUMBLE = auto()\n    CRIT_DAMAGE = auto()\n    STUN = auto()\n\nclass TargetType(Enum):\n    ENEMY = auto(); ALLY = auto()\n    DEAD_ENEMY = auto(); DEAD_ALLY = auto()\n    SELF = auto(); POINT = auto()\n\nclass ActionType(Enum):\n    USE_ABILITY = auto(); MOVE_TO = auto()\n"
    },
    "errors.py": {
      "path": "src/domain/errors.py",
      "content": "# src/domain/errors.py\n\nclass DomainError(Exception):\n    \"\"\"–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –æ—à–∏–±–æ–∫ –¥–æ–º–µ–Ω–∞.\"\"\"\n    pass\n\nclass InvalidAction(DomainError):\n    \"\"\"–ù–µ–≤–∞–ª–∏–¥–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ (–≤—ã—Ö–æ–¥ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã, –Ω–µ —Ç–æ—Ç —Ç–∏–ø —Ü–µ–ª–∏, –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ AP).\"\"\"\n    pass\n\nclass OutOfBounds(InvalidAction):\n    \"\"\"–ü–æ–ø—ã—Ç–∫–∞ –≤—ã–π—Ç–∏ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –ø–æ–ª—è.\"\"\"\n    pass\n\nclass InsufficientAP(InvalidAction):\n    \"\"\"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ—á–∫–æ–≤ –¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏.\"\"\"\n    pass\n\nclass LineOfSightBlocked(InvalidAction):\n    \"\"\"–õ–∏–Ω–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ–º.\"\"\"\n    pass\n\nclass WrongTargetType(InvalidAction):\n    \"\"\"–¶–µ–ª—å –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ (enemy/ally/dead).\"\"\"\n    pass\n"
    },
    "heroes": {
      "README.md": {
        "path": "src/domain/heroes/README.md",
        "content": "# –ü–∞–∫–µ—Ç `heroes`\n\n–°–æ–¥–µ—Ä–∂–∏—Ç —Ñ–∞–±—Ä–∏–∫–∏ `create_*` –∏ –∑–∞–≥–æ—Ç–æ–≤–∫–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π.  \n–ù–µ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç `rules` –∏–ª–∏ `engine` ‚Äî —Ç–æ–ª—å–∫–æ `core`."
      },
      "archer_profile.py": {
        "path": "src/domain/heroes/archer_profile.py",
        "content": "# src/domain/heroes/archer_profile.py\n\nfrom typing import Tuple, Iterable\n\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability\n\ndef arrow_shot(dmg: int = 20, cost: int = 3, rng: int = 5) -> Ability:\n    return Ability(\n        name=\"arrow_shot\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0)\n        }),\n        cast_time=2,\n        aoe=0\n    )\n\ndef crippling_shot(\n    dmg: int = 15,\n    cost: int = 4,\n    rng: int = 4,\n    slow: int = 2,\n    duration: int = 3\n) -> Ability:\n    return Ability(\n        name=\"crippling_shot\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE,     value=dmg,  duration=0),\n            Effect(EffectType.SLOW_AP,    value=slow, duration=duration),\n        }),\n        cast_time=1,\n        aoe=0\n    )\n\ndef sand_throw(\n    chance: int = 50,\n    cost: int = 2,\n    rng: int = 2,\n    duration: int = 1\n) -> Ability:\n    return Ability(\n        name=\"sand_throw\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.BLIND, value=chance, duration=duration)\n        }),\n        cast_time=1,\n        aoe=0\n    )\n\nclass ArcherProfile(CharacterProfile):\n    def __init__(self) -> None:\n        self._max_hp        = 75\n        self._max_ap        = 16\n        self._ap_regen      = 2\n        self._luck: int     = 30\n\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            arrow_shot(dmg=20, cost=3, rng=5),\n            crippling_shot(dmg=15, cost=4, rng=4, slow=1, duration=3),\n            sand_throw(chance=50, cost=2, rng=2, duration=3),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n    \n    @property\n    def luck(self):\n        return self._luck"
      },
      "assassin_profile.py": {
        "path": "src/domain/heroes/assassin_profile.py",
        "content": "# src/domain/heroes/assassin_profile.py\n\nfrom typing import Tuple, Iterable\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability, melee_attack, sprint\nfrom .swordsman_profile import activate_dodge\n\ndef stun_strike(\n    dmg: int = 15,\n    cost: int = 4,\n    rng: int = 1,\n    duration: int = 2\n) -> Ability:\n    return Ability(\n        name=\"stun_strike\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0),\n            Effect(EffectType.STUN,   value=2,   duration=duration),\n        }),\n        cast_time=2,\n        aoe=0,\n    )\n\nclass AssassinProfile(CharacterProfile):\n    \"\"\"\n    –í—ã—Å–æ–∫–∞—è –º–æ–±–∏–ª—å–Ω–æ—Å—Ç—å, —Å–∏–ª—å–Ω—ã–π –æ–¥–∏–Ω–æ—á–Ω—ã–π —É—Ä–æ–Ω –∏ –∫–æ–Ω—Ç—Ä–æ–ª—å:\n      - —Å—Ä–µ–¥–Ω–∏–π HP, –≤—ã—Å–æ–∫–∏–π AP, –æ—Ç–ª–∏—á–Ω—ã–π regen, –≤—ã—Å–æ–∫–∏–π luck (—à–∞–Ω—Å –∫—Ä–∏—Ç–∞)\n      - —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏: –æ–±—â–µ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ, –±–∞–∑–æ–≤–∞—è –∞—Ç–∞–∫–∞, —Ä—ã–≤–æ–∫, —à–∞–Ω—Å —É–≤–µ—Ä–Ω—É—Ç—å—Å—è, –æ–≥–ª—É—à–∞—é—â–∏–π —É–¥–∞—Ä\n    \"\"\"\n    def __init__(self) -> None:\n        self._max_hp   = 60\n        self._max_ap   = 20\n        self._ap_regen = 4\n        self._luck     = 50\n\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            melee_attack(dmg=25, cost=2),\n            sprint(extra_tiles=3, cost=2),\n            activate_dodge(chance=50, duration=3, cost=3),\n            stun_strike(dmg=15, cost=4, rng=1, duration=2),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def luck(self) -> int:\n        return self._luck\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n"
      },
      "bard_profile.py": {
        "path": "src/domain/heroes/bard_profile.py",
        "content": "# src/domain/heroes/bard_profile.py\n\nfrom typing import Tuple, Iterable\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability\n\ndef chant_of_valor(\n    ap_bonus: int = 2,\n    cost: int = 4,\n    rng: int = 3,\n    aoe: int = 1,\n    duration: int = 2\n) -> Ability:\n    \"\"\"\n    Inspires nearby allies, boosting their AP regen for a few ticks.\n    \"\"\"\n    return Ability(\n        name=\"chant_of_valor\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ALLY,\n        effects=frozenset({\n            Effect(EffectType.AP_BOOST, value=ap_bonus, duration=duration)\n        }),\n        cast_time=1,\n        aoe=aoe\n    )\n\ndef dirge_of_futility(\n    slow_amount: int = 1,\n    cost: int = 5,\n    rng: int = 3,\n    aoe: int = 1,\n    duration: int = 2\n) -> Ability:\n    \"\"\"\n    Saps the will of enemies in range, slowing their AP regen.\n    \"\"\"\n    return Ability(\n        name=\"dirge_of_futility\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.SLOW_AP, value=slow_amount, duration=duration)\n        }),\n        cast_time=1,\n        aoe=aoe\n    )\n\nclass BardProfile(CharacterProfile):\n    \"\"\"\n    The Bard:\n      - moderate HP, AP, regen\n      - inspires allies and hinders enemies\n    \"\"\"\n    def __init__(self) -> None:\n        self._max_hp   = 80\n        self._max_ap   = 18\n        self._ap_regen = 3\n        self._luck     = 30\n\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            chant_of_valor(ap_bonus=2, cost=4, rng=3, aoe=1, duration=2),\n            dirge_of_futility(slow_amount=1, cost=5, rng=3, aoe=1, duration=2),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def luck(self) -> int:\n        return self._luck\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n"
      },
      "base_abilities.py": {
        "path": "src/domain/heroes/base_abilities.py",
        "content": "# src/domain/heroes/base_abilities.py\n\nfrom typing import FrozenSet\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\n\n\ndef move_to_ability(range: int = 1, cost: int = 1) -> Ability:\n    \"\"\"\n    Universal movement skill.\n    \"\"\"\n    return Ability(\n        name=\"move_to\",\n        range=range,\n        cost=cost,\n        target=TargetType.POINT,\n        effects=frozenset(),      # no effects, just movement\n        cast_time=1,\n        aoe=0,\n        bounces=0,\n        bounce_mult=1.0,\n    )\n\ndef melee_attack(dmg: int = 3, cost: int = 2) -> Ability:\n    \"\"\"\n    Universal basic attack.\n    \"\"\"\n    return Ability(\n        name=\"melee_attack\",\n        range=1,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0)\n        }),\n        cast_time=1,\n        aoe=0,\n        bounces=0,\n        bounce_mult=1.0,\n    )\n\ndef sprint(extra_tiles: int = 2, cost: int = 2) -> Ability:\n    \"\"\"\n    Selfbuff: gain extra movement tiles next tick.\n    \"\"\"\n    return Ability(\n        name=\"sprint\",\n        range=2,\n        cost=cost,\n        target=TargetType.POINT,\n        effects=frozenset({\n            Effect(EffectType.BUFF, value=extra_tiles, duration=1)\n        }),\n        cast_time=1,\n        aoe=0,\n        bounces=0,\n        bounce_mult=1.0,\n    )\n"
      },
      "defender_profile.py": {
        "path": "src/domain/heroes/defender_profile.py",
        "content": "# src/domain/heroes/defender_profile.py\n\nfrom typing import Tuple, Iterable\n\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability, melee_attack, sprint\n\ndef provoke(radius: int = 2, cost: int = 1, duration: int = 2) -> Ability:\n    return Ability(\n        name=\"provoke\",\n        range=3,\n        cost=cost,\n        target=TargetType.SELF,\n        effects=frozenset({\n            Effect(EffectType.TAUNT, value=radius, duration=duration)\n        }),\n        cast_time=2,\n        aoe=0\n    )\n\ndef slow_strike(\n    dmg: int = 15,\n    cost: int = 3,\n    slow: int = 1,\n    duration: int = 2\n) -> Ability:\n    return Ability(\n        name=\"slow_strike\",\n        range=1,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE,  value=dmg,  duration=0),\n            Effect(EffectType.SLOW_AP, value=slow, duration=duration),\n        }),\n        cast_time=1,\n        aoe=0\n    )\n\nclass DefenderProfile(CharacterProfile):\n    def __init__(self) -> None:\n        self._max_hp   = 130\n        self._max_ap   = 12\n        self._ap_regen = 1\n        self._luck: int     = 20\n\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            melee_attack(dmg=15, cost=2),\n            provoke(radius=3, cost=5, duration=3),\n            slow_strike(dmg=15, cost=3, slow=1, duration=3),\n            sprint(extra_tiles=2, cost=2),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n\n    @property\n    def luck(self):\n        return self._luck"
      },
      "mage_dps_profile.py": {
        "path": "src/domain/heroes/mage_dps_profile.py",
        "content": "# src/domain/heroes/mage_dps_profile.py\n\nfrom typing import Tuple, Iterable\n\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability\n\ndef fireball(\n    dmg: int = 30,\n    cost: int = 4,\n    rng: int = 4,\n    aoe: int = 1,\n    cast_time: int = 1\n) -> Ability:\n    \"\"\"\n    A fiery ball that explodes on impact, dealing area damage.\n    \"\"\"\n    return Ability(\n        name=\"fireball\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0)\n        }),\n        cast_time=cast_time,\n        aoe=aoe\n    )\n\ndef ice_shard(\n    dmg: int = 15,\n    cost: int = 2,\n    rng: int = 3,\n    slow: int = 1,\n    duration: int = 1,\n    cast_time: int = 1\n) -> Ability:\n    \"\"\"\n    A chilling shard that wounds and slows the target.\n    \"\"\"\n    return Ability(\n        name=\"ice_shard\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0),\n            Effect(EffectType.SLOW_AP, value=slow, duration=duration),\n        }),\n        cast_time=cast_time,\n        aoe=0\n    )\n\ndef chain_lightning(\n    dmg: int = 30,\n    bounces: int = 2,\n    bounce_mult: float = 0.5,\n    cost: int = 5,\n    rng: int = 3,\n    cast_time: int = 1\n) -> Ability:\n    \"\"\"\n    A lightning bolt that arcs between multiple enemies.\n    \"\"\"\n    return Ability(\n        name=\"chain_lightning\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0)\n        }),\n        cast_time=cast_time,\n        aoe=3,\n        bounces=bounces,\n        bounce_mult=bounce_mult\n    )\n\nclass MageDpsProfile(CharacterProfile):\n    \"\"\"\n    Immutable profile for the DPS Mage class:\n      - low HP, full AP, moderate regen\n      - high burst damage and crowd‚Äêcontrol spells\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._max_hp: int   = 60\n        self._max_ap: int   = 24\n        self._ap_regen: int = 2\n        self._luck: int     = 15\n\n        # cache abilities to enforce immutability\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            fireball(dmg=30, cost=10, rng=4, aoe=1, cast_time=3),\n            ice_shard(dmg=15, cost=5, rng=3, slow=1, duration=2, cast_time=2),\n            chain_lightning(dmg=45, bounces=2, bounce_mult=0.5, cost=12, rng=2, cast_time=1),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n\n    @property\n    def luck(self):\n        return self._luck"
      },
      "mage_supp_profile.py": {
        "path": "src/domain/heroes/mage_supp_profile.py",
        "content": "# src/domain/heroes/mage_supp_profile.py\n\nfrom typing import Tuple, Iterable\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability\n\ndef mana_shield(\n    shield_hp: int = 50,\n    cost: int = 6,\n    rng: int = 5,\n    duration: int = 4\n) -> Ability:\n    \"\"\"\n    Grant an ally a temporary shield that absorbs damage.\n    \"\"\"\n    return Ability(\n        name=\"mana_shield\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ALLY,\n        effects=frozenset({\n            Effect(EffectType.SHIELD, value=shield_hp, duration=duration)\n        }),\n        cast_time=1,\n        aoe=0\n    )\n\ndef time_warp(\n    extra_ap: int = 4,\n    cost: int = 8,\n    rng: int = 2,\n    duration: int = 1\n) -> Ability:\n    \"\"\"\n    Boost an ally‚Äôs AP for a short time.\n    \"\"\"\n    return Ability(\n        name=\"time_warp\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ALLY,\n        effects=frozenset({\n            Effect(EffectType.AP_BOOST, value=extra_ap, duration=duration)\n        }),\n        cast_time=1,\n        aoe=0\n    )\n\ndef healing_wave(\n    heal_amount: int = 20,\n    cost: int = 6,\n    rng: int = 3,\n    aoe: int = 1,\n    cast_time: int = 2\n) -> Ability:\n    \"\"\"\n    A wave of restorative magic that heals all allies in an area.\n    \"\"\"\n    return Ability(\n        name=\"healing_wave\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ALLY,\n        effects=frozenset({\n            Effect(EffectType.HEAL, value=heal_amount, duration=0)\n        }),\n        cast_time=cast_time,\n        aoe=aoe\n    )\n\ndef arcane_barrier(\n    shield_hp: int = 30,\n    cost: int = 8,\n    rng: int = 3,\n    aoe: int = 1,\n    duration: int = 2\n) -> Ability:\n    \"\"\"\n    Creates a magical barrier that shields multiple allies.\n    \"\"\"\n    return Ability(\n        name=\"arcane_barrier\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ALLY,\n        effects=frozenset({\n            Effect(EffectType.SHIELD, value=shield_hp, duration=duration)\n        }),\n        cast_time=2,\n        aoe=aoe\n    )\n\nclass MageSuppProfile(CharacterProfile):\n    \"\"\"\n    Immutable profile for the Support Mage:\n      - low HP, full AP pool, moderate regen\n      - specializes in shielding, AP boosts, and group healing\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._max_hp: int   = 55\n        self._max_ap: int   = 24\n        self._ap_regen: int = 3\n        self._luck: int     = 40\n\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            mana_shield(shield_hp=50, cost=6, rng=5, duration=4),\n            time_warp(extra_ap=4, cost=8, rng=2, duration=1),\n            healing_wave(heal_amount=20, cost=6, rng=3, aoe=1, cast_time=2),\n            arcane_barrier(shield_hp=30, cost=8, rng=3, aoe=1, duration=2),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n\n    @property\n    def luck(self):\n        return self._luck\n"
      },
      "profile.py": {
        "path": "src/domain/heroes/profile.py",
        "content": "# src/domain/heroes/profile.py\n\nfrom abc import ABC, abstractmethod\nfrom typing import Iterable\nfrom ..core.ability import Ability\n\nclass CharacterProfile(ABC):\n    \"\"\"\n    Value object describing immutable base parameters\n    and abilities of a hero class.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def max_hp(self) -> int:\n        \"\"\"Maximum health points.\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def max_ap(self) -> int:\n        \"\"\"Maximum action points.\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def ap_regen(self) -> int:\n        \"\"\"Action points regained per tick.\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def luck(self) -> int:\n        \"\"\"luck value.\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def abilities(self) -> Iterable[Ability]:\n        \"\"\"Base abilities available to this hero.\"\"\"\n        ...\n\n    \n"
      },
      "swordsman_profile.py": {
        "path": "src/domain/heroes/swordsman_profile.py",
        "content": "# src/domain/heroes/swordsman_profile.py\n\nfrom typing import Tuple\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability, melee_attack, sprint\n\ndef activate_dodge(chance: int = 50, duration: int = 1, cost: int = 1) -> Ability:\n    return Ability(\n        name=\"activate_dodge\",\n        range=0,\n        cost=cost,\n        target=TargetType.SELF,\n        effects=frozenset({Effect(EffectType.DODGE, chance, duration)}),\n        cast_time=2\n    )\n\ndef cleave(dmg: int = 25, duration: int = 0, cost: int = 4) -> Ability:\n    return Ability(\n        name=\"cleave\",\n        range=1,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({Effect(EffectType.DAMAGE, dmg, duration)}),\n        aoe=1,\n        cast_time=2\n    )\n\nclass SwordsmanProfile(CharacterProfile):\n    def __init__(self) -> None:\n        self._max_hp = 110\n        self._max_ap = 16\n        self._ap_regen = 2\n        self._luck = 25\n        self._abilities: Tuple[Ability, ...] = (\n            # –±–∞–∑–æ–≤—ã–µ\n            move_to_ability(range=1, cost=1),\n            melee_attack(dmg=25, cost=3),\n            sprint(extra_tiles=2, cost=2),\n            # —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –º–µ—á–Ω–∏–∫–∞\n            activate_dodge(chance=50, duration=1, cost=1),\n            cleave(dmg=25, duration=0, cost=4),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def abilities(self):\n        return self._abilities\n\n    @property\n    def luck(self):\n        return self._luck"
      }
    },
    "engine": {
      "__init__.py": {
        "path": "src/domain/engine/__init__.py",
        "content": ""
      },
      "ability_utils.py": {
        "path": "src/domain/engine/ability_utils.py",
        "content": "# src/domain/engine/ability_utils.py\n\nfrom typing import List\nfrom ..core.unit import HeroUnit\nfrom ..geometry.position import Position\n\n\n\ndef select_chain_targets(\n    center: Position,\n    state: \"GameState\",\n    max_targets: int = 3,\n    radius: int = 5\n) -> List[HeroUnit]:\n    \"\"\"\n    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–æ max_targets –±–ª–∏–∂–∞–π—à–∏—Ö –∂–∏–≤—ã—Ö —é–Ω–∏—Ç–æ–≤ (–∫—Ä–æ–º–µ primary)\n    –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —Ä–∞–¥–∏—É—Å–∞ manhattan –æ—Ç center.\n    \"\"\"\n    units = [\n        u for u in state.units.values()\n        if u.is_alive() and u.pos != center and u.pos.distance(center) <= radius\n    ]\n    units.sort(key=lambda u: u.pos.distance(center))\n    return units[:max_targets]\n"
      },
      "applier.py": {
        "path": "src/domain/engine/applier.py",
        "content": "# src/domain/engine/applier.py\n\nimport random\nfrom typing import List\n\nfrom domain.engine.combat import calculate_damage\nfrom ..core.state import GameState\nfrom ..core.unit import HeroUnit\nfrom ..core.ability import Ability\nfrom ..core.effect import EffectType, Effect\n\nfrom ..analytics.stats import stats_tracker\nfrom ..geometry.position import Position\n\nfrom config.logger import RTS_Logger\n\nlogger = RTS_Logger()\n\n\ndef apply_ability(\n    state: GameState,\n    caster: HeroUnit,\n    ability: Ability,\n    target_pos: Position\n) -> None:\n    # –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–∫—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n    stats_tracker.record_use(caster.id, ability.name)\n    logger.log_lvl2(f\"Caster {caster.id} uses '{ability.name}' on {target_pos}\")\n\n    # —Å–æ–±–µ—Ä—ë–º —Å–ø–∏—Å–æ–∫ —Ü–µ–ª–µ–π\n    primary = state.get_unit_at(target_pos)\n    targets: List[HeroUnit] = [primary] if primary else []\n\n    if ability.aoe > 0:\n        for u in state.units.values():\n            if u is not primary and u.pos.distance(target_pos) <= ability.aoe:\n                targets.append(u)\n\n    # –ø—Ä–∏–º–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤\n    for u in targets:\n        for eff in ability.effects:\n\n            blinds = [e for e in u.effects if e.type is EffectType.BLIND]\n            if blinds:\n                blind = blinds[0]\n                roll = random.uniform(0, 100)\n                logger.log_lvl2(f\"Unit {u.id} BLIND roll={roll:.2f} vs chance={blind.value}\")\n                if roll < blind.value:\n                    logger.log_lvl2(f\"Unit {u.id} evades '{ability.name}' due to BLIND\")\n                    continue\n\n            # 1) –£—Ä–æ–Ω ‚Äî —á–µ—Ä–µ–∑ calculate_damage (—É—á—ë—Ç crit/fumble, BUFF/DEBUFF –Ω–∞ –∫–∞—Å—Ç–µ—Ä–µ)\n            if eff.type is EffectType.DAMAGE:\n                dmg = calculate_damage(caster, ability)\n                dealt = u.apply_damage(dmg)\n                enemy = (u.team != caster.team)\n                stats_tracker.record_damage(caster.id, ability.name, dealt, enemy)\n                logger.log_lvl3(f\"Unit {u.id} took {dealt} damage (rolled {dmg})\")\n\n            # 2) –õ–µ—á–µ–Ω–∏–µ ‚Äî –∫–∞–∫ –±—ã–ª–æ\n            elif eff.type is EffectType.HEAL:\n                healed = u.apply_heal(eff.value)\n                stats_tracker.record_heal(caster.id, ability.name, healed)\n                logger.log_lvl3(f\"Unit {u.id} healed {healed}\")\n\n            # 3) –í—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã (BUFF, DEBUFF, SLOW_AP, AP_BOOST –∏ —Ç.–¥.) ‚Äî –Ω–∞–≤–µ—à–∏–≤–∞–µ–º –Ω–∞ —Ü–µ–ª—å\n            else:\n                u.add_effect(eff)\n                stats_tracker.record_effect(caster.id, ability.name, eff.type, eff.value)\n                logger.log_lvl3(f\"Unit {u.id} gains {eff.type.name} ({eff.value})\")\n"
      },
      "combat.py": {
        "path": "src/domain/engine/combat.py",
        "content": "# src/domain/core/combat.py\n\nfrom typing import Tuple, List\n\nfrom config.logger import RTS_Logger\nfrom domain.core.ability import Ability\nfrom ..core.effect import Effect, EffectType\nimport random\n\nlogger = RTS_Logger()\n\n\ndef calculate_damage(caster: 'HeroUnit', ability: Ability) -> int:\n    \"\"\"\n    –°—á–∏—Ç–∞–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–π —É—Ä–æ–Ω ability + –±–∞—Ñ—Ñ—ã –Ω–∞ —É—Ä–æ–Ω —É –∫–∞—Å—Ç–µ—Ä–∞.\n    \"\"\"\n    # –±–∞–∑–æ–≤—ã–π —É—Ä–æ–Ω –∏–∑ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏\n    base = sum(e.value for e in ability.effects if e.type is EffectType.DAMAGE)\n    # –¥–æ–±–∞–≤–ª—è–µ–º –±–æ–Ω—É—Å—ã –∫ —É—Ä–æ–Ω—É –∏–∑ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ —Ç–∏–ø–∞ BUFF\n    for eff in caster.effects:\n        if eff.type is EffectType.BUFF:\n            base += eff.value\n        elif eff.type is EffectType.DEBUFF:\n            base -= eff.value\n\n    # luck-based crit / fumble\n    luck: int = caster.luck\n    crit_chance: float = min(100.0, getattr(ability, 'crit_base', 5.0) + luck * 0.2)\n    fumble_chance: float = max(0.0, getattr(ability, 'fumble_base', 2.0) - luck * 0.1)\n\n    roll = random.uniform(0, 100)\n    if roll < fumble_chance:\n        logger.log_lvl2(\n            f\"FUMBLE by unit {caster.id}: base={base}, roll={roll:.2f} < fumble_chance={fumble_chance:.2f}\"\n        )\n        return int(base * 0.5)\n    if roll < fumble_chance + crit_chance:\n        logger.log_lvl2(\n            f\"CRIT by unit {caster.id}: base={base}, roll={roll:.2f} < fumble_chance+crit_chance={fumble_chance+crit_chance:.2f}\"\n        )\n        return int(base * 1.5)\n    logger.log_lvl3(\n        f\"HIT by unit {caster.id}: base={base}, roll={roll:.2f} >= fumble_chance+crit_chance={fumble_chance+crit_chance:.2f}\"\n    )\n    return int(base)\n\n\ndef apply_damage_to_unit(unit: 'HeroUnit', amount: int) -> int:\n    \"\"\"\n    –ù–∞–Ω–æ—Å–∏—Ç unit —É—Ä–æ–Ω —Å —É—á—ë—Ç–æ–º:\n      - DODGE: —à–∞–Ω—Å —É–≤–µ—Ä–Ω—É—Ç—å—Å—è\n      - —â–∏—Ç–æ–≤ (SHIELD)\n    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ –Ω–∞–Ω–µ—Å—ë–Ω–Ω—ã–π —É—Ä–æ–Ω.\n    \"\"\"\n    # 1) DODGE\n    dodge_effects = [e for e in unit.effects if e.type is EffectType.DODGE]\n    if dodge_effects:\n        dodge = dodge_effects[0]\n        roll = random.uniform(0, 100)\n        logger.log_lvl2(f\"Unit {unit.id} DODGE roll={roll:.2f} vs chance={dodge.value}\")\n        if roll < dodge.value:\n            # —É–≤–µ—Ä–Ω—É–ª—Å—è ‚Äî —ç—Ñ—Ñ–µ–∫—Ç –æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω–æ —Ä–∞—Å—Ö–æ–¥—É–µ—Ç—Å—è\n            unit.effects.remove(dodge)\n            logger.log_lvl2(f\"Unit {unit.id} dodged the attack!\")\n            return 0\n\n    # 2) —â–∏—Ç—ã\n    remaining = amount\n    shields: List[Effect] = [e for e in unit.effects if e.type is EffectType.SHIELD]\n    if shields:\n        shield = shields[0]\n        logger.log_lvl2(f\"Unit {unit.id} has SHIELD {shield.value}\")\n        absorb = min(shield.value, remaining)\n        unit.effects.remove(shield)\n        if shield.value - absorb > 0:\n            unit.effects.append(Effect(EffectType.SHIELD, shield.value - absorb, shield.duration))\n            logger.log_lvl2(f\"  Remaining SHIELD {shield.value - absorb}\")\n        remaining -= absorb\n        logger.log_lvl2(f\"  After shield absorb remaining={remaining}\")\n\n    # 3) –Ω–∞–Ω–æ—Å–∏–º –æ—Å—Ç–∞–≤—à–∏–π—Å—è —É—Ä–æ–Ω\n    dealt = remaining\n    prev_hp = unit.hp\n    unit.hp = max(0, unit.hp - remaining)\n    logger.log_lvl2(f\"Unit {unit.id} HP {prev_hp}->{unit.hp}, dealt={dealt}\")\n    return dealt\n\ndef apply_heal_to_unit(unit: 'HeroUnit', amount: int) -> int:\n    \"\"\"\n    –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç unit –∑–¥–æ—Ä–æ–≤—å–µ, –Ω–µ –ø—Ä–µ–≤—ã—à–∞—è max_hp.\n    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.\n    \"\"\"\n    if not unit.is_alive():\n        return 0\n\n    before = unit.hp\n    unit.hp = min(unit.profile.max_hp, unit.hp + amount)\n    return unit.hp - before\n\n\ndef add_effect_to_unit(unit: 'HeroUnit', effect: Effect) -> None:\n    \"\"\"\n    –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç –Ω–∞ unit —É–∫–∞–∑–∞–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç (buff/debuff).\n    \"\"\"\n    if unit.is_alive():\n        unit.effects.append(effect)\n"
      },
      "engine.md": {
        "path": "src/domain/engine/engine.md",
        "content": "# üß† `domain.engine/` ‚Äî –õ–æ–≥–∏–∫–∞ —Å–∏–º—É–ª—è—Ü–∏–∏ –±–æ—è\n\n–ú–æ–¥—É–ª—å `domain.engine` —Å–æ–¥–µ—Ä–∂–∏—Ç **—è–¥—Ä–æ —Å–∏–º—É–ª—è—Ü–∏–∏ –∏–≥—Ä–æ–≤–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø–æ —Ç–∏–∫–æ–≤–æ–π –º–æ–¥–µ–ª–∏**.  \n–û–Ω –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞:\n\n- –ø—Ä–æ–≥—Ä–µ—Å—Å —Ç–∏–∫–∞ (`event_tick`)\n- –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π (`apply_ability`)\n- —Ä–∞—Å—á–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ (`damage`, `heal`, `effects`)\n- –≤—ã–±–æ—Ä —Ü–µ–ª–µ–π (`chain targeting`)\n- –∑–∞–ø–∏—Å—å –±–æ–µ–≤–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (`stats_tracker`)\n\n---\n\n## üîÅ `event_loop.py` ‚Äî –≥–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª —Å–∏–º—É–ª—è—Ü–∏–∏\n\n–§—É–Ω–∫—Ü–∏—è `event_tick(state, intents)`:\n\n1. **–û–±–Ω–æ–≤–ª—è–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç—ã** (—É–º–µ–Ω—å—à–∞–µ—Ç –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å).\n2. **–ü—Ä–∏–º–µ–Ω—è–µ—Ç —Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∑–æ–Ω—ã** (regen_zone).\n3. **–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç AP**.\n4. **–í—ã–ø–æ–ª–Ω—è–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è —é–Ω–∏—Ç–æ–≤**:\n   - –µ—Å–ª–∏ –∏–¥–µ—Ç –∫–∞—Å—Ç ‚Üí –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º\n   - –µ—Å–ª–∏ –ø—Ä–∏—à–µ–ª –Ω–æ–≤—ã–π –∏–Ω—Ç–µ–Ω—Ç ‚Üí –ø—Ä–µ—Ä—ã–≤–∞–µ–º –∏ –∑–∞–º–µ–Ω—è–µ–º\n   - –∏–Ω–∞—á–µ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ç–µ–∫—É—â–µ–µ (–¥–≤–∏–∂–µ–Ω–∏–µ/–æ–∂–∏–¥–∞–Ω–∏–µ)\n\n**–ï—Å–ª–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –∏ —Å–æ–¥–µ—Ä–∂–∏—Ç —ç—Ñ—Ñ–µ–∫—Ç—ã** ‚Äî –æ–Ω–∞ –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –≤ `apply_ability`.\n\n---\n\n## ‚ú® `applier.py` ‚Äî –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π\n\n–§—É–Ω–∫—Ü–∏—è `apply_ability(...)`:\n- —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ `stats_tracker`\n- –≤—ã–±–∏—Ä–∞–µ—Ç —Ü–µ–ª–∏ (—É—á–∏—Ç—ã–≤–∞—è AoE)\n- –ø—Ä–∏–º–µ–Ω—è–µ—Ç –∫–∞–∂–¥—ã–π `Effect`:\n  - `DAMAGE` ‚Üí `apply_damage_to_unit`\n  - `HEAL` ‚Üí `apply_heal_to_unit`\n  - `BUFF/DEBUFF/SHIELD` ‚Üí `add_effect_to_unit`\n\n---\n\n## üîó `ability_utils.py` ‚Äî –≤—ã–±–æ—Ä —Ü–µ–ª–µ–π\n\n- `select_chain_targets(...)` ‚Äî –¥–ª—è —Ü–µ–ø–Ω—ã—Ö –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–π:\n  –≤—ã–±–∏—Ä–∞–µ—Ç –¥–æ N –±–ª–∏–∂–∞–π—à–∏—Ö —Ü–µ–ª–µ–π –≤ —Ä–∞–¥–∏—É—Å–µ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞.\n\n---\n\n## üß™ `combat.py` ‚Äî –ø—Ä–∏–º–∏—Ç–∏–≤—ã —É—Ä–æ–Ω–∞/—Ö–∏–ª–∞\n\n- `calculate_damage()` ‚Äî —É—á–∏—Ç—ã–≤–∞–µ—Ç –≤—Å–µ BUFF-—ç—Ñ—Ñ–µ–∫—Ç—ã.\n- `apply_damage_to_unit()` ‚Äî —É—Ä–æ–Ω —Å —É—á–µ—Ç–æ–º —â–∏—Ç–∞.\n- `apply_heal_to_unit()` ‚Äî —Ö–∏–ª –¥–æ max_hp.\n- `add_effect_to_unit()` ‚Äî –Ω–∞–≤–µ—à–∏–≤–∞–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç.\n\n---\n\n## üß© –í–∑–∞–∏–º–æ—Å–≤—è–∑–∏:\n\n- `event_loop` –≤—ã–∑—ã–≤–∞–µ—Ç `apply_ability`\n- `apply_ability` –≤—ã–∑—ã–≤–∞–µ—Ç `combat` –∏ `stats`\n- –í—Å–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å `GameState` –∏ `HeroUnit`\n\n---\n\n## üí° –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:\n\n```python\nstate, executed, done = event_tick(state, intents)\n```\n\n---\n\n## üìå –ì–¥–µ –ª–æ–≥–∏–∫–∞ –ù–ï –∂–∏–≤–µ—Ç:\n- –ù–∏–∫–∞–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫ —É—Å–ª–æ–≤–∏–π/AI ‚Äî —Ç–æ–ª—å–∫–æ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ.\n- –í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ (LoS, range) –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Å–¥–µ–ª–∞–Ω—ã –¥–æ –ø–µ—Ä–µ–¥–∞—á–∏ `intent`."
      },
      "event_loop.py": {
        "path": "src/domain/engine/event_loop.py",
        "content": "# src/domain/engine/event_loop.py\n\nfrom typing import Dict, Optional\nfrom ..core.state import GameState\nfrom ..core.action import ActiveAction\nfrom ..core.effect import EffectType\nfrom ..core.ability import Ability\nfrom ..core.unit import HeroUnit\nfrom .applier import apply_ability\nfrom ..errors import DomainError\nfrom config.logger import RTS_Logger\n\nlogger = RTS_Logger(__name__)\n\ndef apply_effects(unit: HeroUnit, state: GameState) -> Optional[ActiveAction]:\n    \"\"\"\n    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç—ã –Ω–∞ –≤—Ä–∞–∂–µ—Å–∫–∏—Ö —é–Ω–∏—Ç–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, TAUNT) –∏,\n    –µ—Å–ª–∏ –Ω—É–∂–Ω–æ, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–æ–≤—ã–π ActiveAction, –∫–æ—Ç–æ—Ä—ã–º —Å–ª–µ–¥—É–µ—Ç\n    –∑–∞–º–µ–Ω–∏—Ç—å intent —ç—Ç–æ–≥–æ —é–Ω–∏—Ç–∞.\n    \"\"\"\n    for other in state.units.values():\n        if other.team != unit.team and other.is_alive():\n            for eff in other.effects:\n                if eff.type is EffectType.TAUNT and other.pos.distance(unit.pos) <= eff.value:\n                    # –≤—Ä–∞–∂–µ—Å–∫–∏–π —é–Ω–∏—Ç other —Ç–∞—É–Ω—Ç–∏—Ç —ç—Ç–æ–≥–æ unit\n                    melee = next((ab for ab in unit.profile.abilities if ab.name == \"melee_attack\"), None)\n                    if melee and unit.ap >= melee.cost and unit.pos.distance(other.pos) <= melee.range:\n                        logger.log_lvl2(f\"Unit {unit.id} is taunted by {other.id}: will melee_attack\")\n                        return ActiveAction(\n                            ability=melee,\n                            target=other.pos,\n                            target_unit_id=other.id,\n                            ticks_remaining=melee.cast_time,\n                            path=None,\n                            started=False\n                        )\n                    move = next((ab for ab in unit.profile.abilities if ab.name == \"move_to\"), None)\n                    if move:\n                        logger.log_lvl2(f\"Unit {unit.id} is taunted by {other.id}: will move_to\")\n                        return ActiveAction(\n                            ability=move,\n                            target=other.pos,\n                            target_unit_id=other.id,\n                            ticks_remaining=move.cast_time,\n                            path=None,\n                            started=False\n                        )\n    return None\n\ndef event_tick(\n    state: GameState,\n    action_intents: Dict[int, ActiveAction]\n) -> tuple[GameState, Dict[int, bool], bool]:\n    executed: Dict[int, bool] = {}\n    logger.log_lvl2(f\"=== Tick {state.tick} START ===\")\n    \n    # –®–∞–≥ 0. –û—á–∏—Å—Ç–∏—Ç—å completed_action, –æ—Å—Ç–∞–≤—à–µ–µ—Å—è –ø–æ—Å–ª–µ –ø—Ä–æ—à–ª–æ–≥–æ —Ç–∏–∫–∞\n    for u in state.units.values():\n        u.completed_action = None\n\n    # 1) Aging status effects\n    for u in state.units.values():\n        if u.is_alive:\n            u.tick_effects()\n\n    # 2) Zone effects\n    state.board.apply_zone_effects(state)\n\n    # 3) AP regen\n    for u in state.units.values():\n        if u.is_alive():\n            prev = u.ap\n            u.apply_ap_regen()\n            logger.log_lvl3(f\"Unit {u.id} AP regen {prev}->{u.ap}\")\n\n    # 4) Build intents including effect overrides\n    intents = dict(action_intents)\n    for u in state.units.values():\n        if not u.is_alive():\n            continue\n        override = apply_effects(u, state)\n        if override:\n            intents[u.id] = override\n\n    # 5) STUN: skip any stunned unit\n    for u in state.units.values():\n        if not u.is_alive():\n            continue\n        if any(e.type is EffectType.STUN for e in u.effects):\n            logger.log_lvl2(f\"Unit {u.id} is stunned and skips its turn\")\n            intents.pop(u.id, None)\n\n    # 6) Execute actions\n    for u in state.units.values():\n        executed[u.id] = False\n        if not u.is_alive():\n            continue\n\n        # a) finish ongoing cast\n        act = u.current_action\n        if act and getattr(act, \"started\", False):\n            comp = u.advance_action(state)\n            if comp:\n                tgt = state.units[comp.target_unit_id].pos if comp.target_unit_id is not None else comp.target\n                apply_ability(state, u, comp.ability, tgt)\n                executed[u.id] = True\n            continue\n\n        # b) start or overridden intent\n        intent = intents.get(u.id)\n        if intent:\n            try:\n                u.start_action(intent.ability, intent.target, state, intent.target_unit_id)\n                executed[u.id] = True\n            except DomainError as e:\n                logger.log_lvl1(f\"Unit {u.id} intent failed: {e}\")\n            continue\n\n        # c) continue current_action\n        comp = u.advance_action(state)\n        if comp and (comp.ability.effects or comp.ability.aoe > 0):\n            tgt = state.units[comp.target_unit_id].pos if comp.target_unit_id is not None else comp.target\n            apply_ability(state, u, comp.ability, tgt)\n            executed[u.id] = True\n\n    state.tick += 1\n    logger.log_lvl2(f\"=== Tick {state.tick-1} END ===\")\n    return state, executed, state.is_game_over()\n"
      }
    },
    "factory": {
      "game_factory.py": {
        "path": "src/domain/factory/game_factory.py",
        "content": "# src/domain/factory/game_factory.py\n\nfrom typing import Dict, Set\nfrom ..core.state import GameState\nfrom ..core.board import Board\nfrom ..factory.unit_factory import create_heroes_for_setup\nfrom ..geometry.position import Position\nfrom ..core.unit import HeroUnit\nfrom ..constants import TeamId\nfrom config.logger import RTS_Logger\n\n\nlogger = RTS_Logger()\n\ndef build_new_game(\n    *,\n    tick: int = 0,\n    hero_setup: Dict[TeamId, list[\"HeroConfig\"]],\n    obstacles: Set[Position],\n    regen_zone: Set[Position],\n) -> GameState:\n    \"\"\"\n    –°–æ–±–∏—Ä–∞–µ—Ç –Ω–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã:\n      - hero_setup: –æ–ø–∏—Å–∞–Ω–∏–µ —é–Ω–∏—Ç–æ–≤ –Ω–∞ —Å—Ç–∞—Ä—Ç–µ\n      - obstacles, regen_zone: –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–∞—Ä—Ç—ã\n    \"\"\"\n    \n\n    # 1. –°–æ–∑–¥–∞—ë–º –≤—Å–µ—Ö —é–Ω–∏—Ç–æ–≤\n    heroes: list[HeroUnit] = create_heroes_for_setup(hero_setup)\n    units: Dict[int, HeroUnit] = {u.id: u for u in heroes}\n\n    # 2. –°–æ–∑–¥–∞—ë–º –∫–∞—Ä—Ç—É\n    board = Board(obstacles=obstacles, regen_zone=regen_zone)\n\n    # 3. –õ–æ–≥–≥–∏—Ä—É–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã\n    logger.log_lvl2(f\"GameState created: tick={tick}, units={len(units)}\")\n    for u in units.values():\n        logger.log_lvl3(\n            f\"Unit {u.id} | team={u.team} | pos={u.pos} | hp={u.hp}/{u.profile.max_hp} | ap={u.ap}/{u.profile.max_ap}\"\n        )\n\n    # 4. –í–æ–∑–≤—Ä–∞—â–∞–µ–º GameState\n    return GameState(tick=tick, units=units, board=board)\n\n"
      },
      "unit_factory.py": {
        "path": "src/domain/factory/unit_factory.py",
        "content": "# src/domain/factory/unit_factory.py\n\nfrom typing import Dict, List\n\nfrom config.config_loader import HeroConfig\nfrom ..constants import TeamId\nfrom ..geometry.position import Position\nfrom ..core.unit import HeroUnit\nfrom ..enums import UnitRole\n\nfrom ..heroes.swordsman_profile import SwordsmanProfile\nfrom ..heroes.defender_profile import DefenderProfile\nfrom ..heroes.archer_profile    import ArcherProfile\nfrom ..heroes.mage_dps_profile  import MageDpsProfile\nfrom ..heroes.mage_supp_profile import MageSuppProfile\nfrom ..heroes.assassin_profile import AssassinProfile\nfrom ..heroes.bard_profile import BardProfile\n\n# –º–∞–ø–ø–∏–Ω–≥ —Ä–æ–ª–∏ ‚Üí –∫–ª–∞—Å—Å –ø—Ä–æ—Ñ–∏–ª—è\n_PROFILE_MAP: Dict[UnitRole, type] = {\n    UnitRole.SWORDSMAN:    SwordsmanProfile,\n    UnitRole.SHIELD:   DefenderProfile,\n    UnitRole.ARCHER:   ArcherProfile,\n    UnitRole.MAGE_DPS: MageDpsProfile,\n    UnitRole.MAGE_SUPP: MageSuppProfile,\n    UnitRole.ASSASSIN: AssassinProfile,\n    UnitRole.BARD: BardProfile\n}\n\ndef create_heroes_for_setup(\n    hero_setup: Dict[TeamId, List[\"HeroConfig\"]]\n) -> List[HeroUnit]:\n    \"\"\"\n    –î–ª—è –∫–∞–∂–¥–æ–≥–æ HeroConfig:\n      - –±–µ—Ä—ë–º —Ä–æ–ª—å\n      - –∏–Ω—Å—Ç–∞–Ω—Ü–∏—Ä—É–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π CharacterProfile\n      - —Å–æ–∑–¥–∞—ë–º HeroUnit(id, role, team, pos, profile)\n    \"\"\"\n    units: List[HeroUnit] = []\n    uid = 1\n\n    for team, heroes in hero_setup.items():\n        for hc in heroes:\n            role = UnitRole[hc.role]\n            pos = Position(*hc.pos)\n            profile_cls = _PROFILE_MAP[role]\n            profile = profile_cls()  # Composition: –µ–¥–∏–Ω—ã–π HeroUnit + –ø—Ä–æ—Ñ–∏–ª—å\n            unit = HeroUnit(\n                id=uid,\n                role=role,\n                team=team,\n                pos=pos,\n                profile=profile\n            )\n            units.append(unit)\n            uid += 1\n\n    return units\n"
      }
    },
    "analytics": {
      "analytics.md": {
        "path": "src/domain/analytics/analytics.md",
        "content": "# üìä Domain Analytics\n\n–ü–∞–ø–∫–∞ `src/domain/analytics` –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ —Å–±–æ—Ä –∏ —Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä—ã –Ω–∞ —É—Ä–æ–≤–Ω–µ –¥–æ–º–µ–Ω–∞:\n- —Å–∫–æ–ª—å–∫–æ —Ä–∞–∑ –∫–∞–∂–¥—ã–π —é–Ω–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –∫–∞–∂–¥—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å;\n- —Å–∫–æ–ª—å–∫–æ —É—Ä–æ–Ω–∞ –æ–Ω –Ω–∞–Ω—ë—Å –≤—Ä–∞–≥–∞–º –∏ —Å–æ—é–∑–Ω–∏–∫–∞–º;\n- —Å–∫–æ–ª—å–∫–æ –∏—Å—Ü–µ–ª–∏–ª;\n- –∫–∞–∫–∏–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –Ω–∞–ª–æ–∂–∏–ª –∏ –≤ –∫–∞–∫–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ.\n\n–í —ç—Ç–æ–π –ø–∞–ø–∫–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –º–æ–¥—É–ª—å:\n\n---\n\n## stats.py\n\n```python\nfrom dataclasses import dataclass, field\nfrom typing import Dict\nfrom ..core.effect import EffectType\n\n@dataclass\nclass AbilityStats:\n    uses: int = 0\n    damage_to_enemies: int = 0\n    damage_to_allies: int = 0\n    healing: int = 0\n    effects_applied: Dict[EffectType, int] = field(default_factory=dict)\n\n@dataclass\nclass UnitStats:\n    by_ability: Dict[str, AbilityStats] = field(default_factory=dict)\n\nclass StatsTracker:\n    \"\"\"\n    –°–æ–±–∏—Ä–∞–µ—Ç per-tick –∏ –∏—Ç–æ–≥–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∫–∞–∂–¥–æ–º—É —é–Ω–∏—Ç—É:\n      - record_use       ‚Äî —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏\n      - record_damage    ‚Äî —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç —Å–∫–æ–ª—å–∫–æ —É—Ä–æ–Ω–∞ –Ω–∞–Ω–µ—Å–µ–Ω–æ –∏ –∫–æ–º—É (–≤—Ä–∞–≥/—Å–æ—é–∑–Ω–∏–∫)\n      - record_heal      ‚Äî —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç —Å–∫–æ–ª—å–∫–æ –∏—Å—Ü–µ–ª–µ–Ω–æ\n      - record_effect    ‚Äî —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç, —Å–∫–æ–ª—å–∫–æ –∏ –∫–∞–∫–∏—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –Ω–∞–ª–æ–∂–µ–Ω–æ\n      - get_stats        ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Ç–æ–≥–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –≤—Å–µ–º —é–Ω–∏—Ç–∞–º\n      - reset            ‚Äî –æ—á–∏—â–∞–µ—Ç –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ\n    \"\"\"\n    def __init__(self):\n        self.units: Dict[int, UnitStats] = {}\n\n    def _get_ability_stats(self, caster_id: int, ability_name: str) -> AbilityStats:\n\n    def record_use(self, caster_id: int, ability_name: str) -> None:\n\n    def record_damage(self, caster_id: int, ability_name: str, amount: int, enemy: bool) -> None:\n\n    def record_heal(self, caster_id: int, ability_name: str, amount: int) -> None:\n    \n    def record_effect(self, caster_id: int, ability_name: str, eff_type: EffectType, amount: int) -> None:\n\n    def get_stats(self) -> Dict[int, UnitStats]:\n\n    def reset(self) -> None:\n        \n\n# –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ç—Ä–µ–∫–µ—Ä, –¥–æ—Å—Ç—É–ø–Ω—ã–π –≤–æ –≤—Å—ë–º –¥–æ–º–µ–Ω–µ\nstats_tracker = StatsTracker()\n–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç\n–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ –¥–æ–º–µ–Ω\n–í —Ñ—É–Ω–∫—Ü–∏–∏ apply_ability (–≤ domain/engine/applier.py) –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –≤—ã–∑—ã–≤–∞—é—Ç—Å—è –º–µ—Ç–æ–¥—ã stats_tracker.record_*, —á—Ç–æ–±—ã –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å:\n\n—Ñ–∞–∫—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è (record_use),\n\n–ø—Ä–∏–Ω–µ—Å—ë–Ω–Ω—ã–π —É—Ä–æ–Ω (record_damage),\n\n–æ—Ç—Ö–∏–ª (record_heal),\n\n–Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ–º—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã (record_effect).\n\n–°–±–æ—Ä –∏ —Ö—Ä–∞–Ω–µ–Ω–∏–µ\nStatsTracker —Ö—Ä–∞–Ω–∏—Ç –≤ –ø–æ–ª–µ units —Å–ª–æ–≤–∞—Ä—å:\n\npython\n\n{\n  unit_id: UnitStats(by_ability={\n    \"fireball\": AbilityStats(...),\n    \"move_to\":  AbilityStats(...),\n    ...\n  }),\n  ...\n}\n–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤\n–í –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö —Ç–∏–∫–æ–≤) –º–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å:\n\npython\nCopy\nEdit\nfrom domain.analytics.stats import stats_tracker\nfinal_stats = stats_tracker.get_stats()\n–∏ –ø–æ–ª—É—á–∏—Ç—å –ø–æ–¥—Ä–æ–±–Ω—É—é —Ä–∞–∑–±–∏–≤–∫—É –ø–æ –∫–∞–∂–¥–æ–º—É —é–Ω–∏—Ç—É –∏ –∫–∞–∂–¥–æ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏.\n\n–°–±—Ä–æ—Å\n–ï—Å–ª–∏ –Ω—É–∂–Ω–æ –Ω–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –º–∞—Ç—á –∏–ª–∏ —Ç–µ—Å—Ç, –≤—ã–∑—ã–≤–∞–µ–º stats_tracker.reset(), —á—Ç–æ–±—ã –æ—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ —Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ.\n\n–ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n\n# ... –≤ –Ω–∞—á–∞–ª–µ –∏–≥—Ä—ã\nstats_tracker.reset()\n\n# –≤–æ –≤—Ä–µ–º—è –∏–≥—Ä—ã ‚Äî –≤—Å—ë –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–Ω—É—Ç—Ä–∏ apply_ability\n\n# –≤ –∫–æ–Ω—Ü–µ –∏–≥—Ä—ã\nfor unit_id, u_stats in stats_tracker.get_stats().items():\n    print(f\"–Æ–Ω–∏—Ç {unit_id}:\")\n    for ability_name, ab in u_stats.by_ability.items():\n        print(f\"  {ability_name}: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ {ab.uses} —Ä–∞–∑, \"\n              f\"—É—Ä–æ–Ω –≤—Ä–∞–≥–∞–º={ab.damage_to_enemies}, —É—Ä–æ–Ω —Å–æ—é–∑–Ω–∏–∫–∞–º={ab.damage_to_allies}, \"\n              f\"–ª–µ—á–µ–Ω–∏–µ={ab.healing}, —ç—Ñ—Ñ–µ–∫—Ç—ã={ab.effects_applied}\")\n\n–î–∞–Ω–Ω—ã–π –º–æ–¥—É–ª—å –ø–æ–∑–≤–æ–ª—è–µ—Ç –∞–Ω–∞–ª–∏—Ç–∏–∫–∞–º –∏ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º –±—ã—Å—Ç—Ä–æ –ø–æ–ª—É—á–∞—Ç—å –º–µ—Ç—Ä–∏–∫–∏ –ø–æ –±–∞–ª–∞–Ω—Å—É —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π –∏ –ø–æ–≤–µ–¥–µ–Ω–∏—é —é–Ω–∏—Ç–æ–≤ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—Å–Ω–æ–≤–Ω–æ–π –ª–æ–≥–∏–∫–∏ —Å–∏–º—É–ª—è—Ü–∏–∏."
      },
      "stats.py": {
        "path": "src/domain/analytics/stats.py",
        "content": "# src/domain/analytics/stats.py\n\nfrom dataclasses import dataclass, field\nfrom typing import Dict\nfrom ..core.effect import EffectType\n\n\n@dataclass\nclass AbilityStats:\n    uses: int = 0\n    damage_to_enemies: int = 0\n    damage_to_allies: int = 0\n    healing: int = 0\n    effects_applied: Dict[EffectType, int] = field(default_factory=dict)\n\n\n@dataclass\nclass UnitStats:\n    by_ability: Dict[str, AbilityStats] = field(default_factory=dict)\n\n\nclass StatsTracker:\n    \"\"\"\n    –°–æ–±–∏—Ä–∞–µ—Ç per-tick –∏ –∏—Ç–æ–≥–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∫–∞–∂–¥–æ–º—É —é–Ω–∏—Ç—É:\n      - —Å–∫–æ–ª—å–∫–æ —Ä–∞–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –∫–∞–∂–¥—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å,\n      - —Å–∫–æ–ª—å–∫–æ —É—Ä–æ–Ω–∞/—Ö–∏–ª–∞ –Ω–∞–Ω–µ—Å –ø–æ –≤—Ä–∞–≥–∞–º/—Å–æ—é–∑–Ω–∏–∫–∞–º,\n      - —Å–∫–æ–ª—å–∫–æ –∏ –∫–∞–∫–∏—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –Ω–∞–ª–æ–∂–∏–ª.\n    \"\"\"\n    def __init__(self):\n        self.units: Dict[int, UnitStats] = {}\n\n    def _get_ability_stats(self, caster_id: int, ability_name: str) -> AbilityStats:\n        unit_stats = self.units.setdefault(caster_id, UnitStats())\n        return unit_stats.by_ability.setdefault(ability_name, AbilityStats())\n\n    def record_use(self, caster_id: int, ability_name: str) -> None:\n        self._get_ability_stats(caster_id, ability_name).uses += 1\n\n    def record_damage(self, caster_id: int, ability_name: str, amount: int, enemy: bool) -> None:\n        ab = self._get_ability_stats(caster_id, ability_name)\n        if enemy:\n            ab.damage_to_enemies += amount\n        else:\n            ab.damage_to_allies += amount\n\n    def record_heal(self, caster_id: int, ability_name: str, amount: int) -> None:\n        self._get_ability_stats(caster_id, ability_name).healing += amount\n\n    def record_effect(self, caster_id: int, ability_name: str, eff_type: EffectType, amount: int) -> None:\n        ab = self._get_ability_stats(caster_id, ability_name)\n        ab.effects_applied[eff_type] = ab.effects_applied.get(eff_type, 0) + amount\n\n    def get_stats(self) -> Dict[int, UnitStats]:\n        return self.units\n    \n    def reset(self) -> None:\n        self.units: Dict[int, UnitStats] = {}\n\n\n# —Å–æ–∑–¥–∞—Ç—å –æ–¥–∏–Ω –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ç—Ä–µ–∫–µ—Ä\nstats_tracker = StatsTracker()\n"
      }
    },
    "core": {
      "__init__.py": {
        "path": "src/domain/core/__init__.py",
        "content": ""
      },
      "ability.py": {
        "path": "src/domain/core/ability.py",
        "content": "# src/domain/core/ability.py\n\nfrom dataclasses import dataclass\nfrom typing import FrozenSet\nfrom ..enums import EffectType, TargetType\nfrom .effect import Effect\n\n@dataclass(frozen=True, slots=True)\nclass Ability:\n    \"\"\"\n    –û–ø–∏—Å–∞–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏:\n      - name       ‚Äî —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä\n      - range      ‚Äî –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è\n      - cost       ‚Äî —Å—Ç–æ–∏–º–æ—Å—Ç—å AP\n      - target     ‚Äî SELF/ENEMY/ALLY‚Ä¶\n      - effects    ‚Äî –ø–æ–ª–Ω—ã–π –Ω–∞–±–æ—Ä Effect (value+duration)\n      - cast_time  ‚Äî —Ç–∏–∫–æ–≤ –Ω–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ\n      - aoe        ‚Äî —Ä–∞–¥–∏—É—Å –æ–±–ª–∞—Å—Ç–∏ (0=–æ–¥–Ω–æ—Ü–µ–ª–µ–≤–∞—è)\n      - bounces    ‚Äî –¥–ª—è —Ü–µ–ø–æ—á–µ–∫\n      - bounce_mult‚Äî –º–Ω–æ–∂–∏—Ç–µ–ª—å —Å–∏–ª—ã –¥–ª—è –ø—Ä—ã–∂–∫–æ–≤\n    \"\"\"\n    name: str\n    range: int\n    cost: int\n    target: TargetType\n\n    # now a set of full Effect objects\n    effects: FrozenSet[Effect]\n\n    crit_base: float = 5.0     # –±–∞–∑–æ–≤—ã–π —à–∞–Ω—Å –∫—Ä–∏—Ç–∞ –≤ %\n    fumble_base: float = 2.0   # –±–∞–∑–æ–≤—ã–π —à–∞–Ω—Å –ø—Ä–æ–≤–∞–ª–∞ –≤ %\n\n    # timing & extras\n    cast_time: int = 1\n    aoe: int = 0\n    bounces: int = 0\n    bounce_mult: float = 1.0\n"
      },
      "action.py": {
        "path": "src/domain/core/action.py",
        "content": "# src/domain/core/action.py\n\nfrom dataclasses import dataclass, field\nfrom typing import Any, List, Optional\nfrom .ability import Ability\nfrom ..geometry.position import Position\n\n@dataclass\nclass ActiveAction:\n    \"\"\"\n    An in-progress action that may take multiple ticks.\n    \"\"\"\n    ability: Ability\n    target: Position\n    ticks_remaining: int\n    path: Optional[List[Position]] = field(default=None)\n    target_unit_id: Optional[int] = None \n    started: bool = False\n    \n\n    def tick(self) -> bool:\n        \"\"\"\n        Advance one tick; return True if action just completed.\n        \"\"\"\n        self.ticks_remaining -= 1\n        return self.ticks_remaining <= 0\n"
      },
      "board.py": {
        "path": "src/domain/core/board.py",
        "content": "# src/domain/core/board.py\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom typing import Set\n\nfrom ..geometry.position import Position\n\n@dataclass(slots=True)\nclass Board:\n    \"\"\"\n    –ú–∞—Ç—Ä–∏—Ü–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –∏ ¬´–∑–æ–Ω¬ª (—Ä–µ–≥–µ–Ω/–±–∞—Ñ—Ñ):\n      - obstacles   –∫–ª–µ—Ç–∫–∏, –ø–æ –∫–æ—Ç–æ—Ä—ã–º –Ω–µ–ª—å–∑—è —Ö–æ–¥–∏—Ç—å –∏ —Å—Ç—Ä–µ–ª—è—Ç—å\n      - regen_zone  –∫–ª–µ—Ç–∫–∏, –≥–¥–µ –∫–∞–∂–¥—ã–π —Ç–∏–∫ +1 HP\n    \"\"\"\n    obstacles: Set[Position] = field(default_factory=set)\n    regen_zone: Set[Position] = field(default_factory=set)\n\n    def is_blocked(self, pos: Position) -> bool:\n        return pos in self.obstacles\n\n    def is_line_blocked(self, a: Position, b: Position) -> bool:\n        # –ü—Ä–æ—Å—Ç–∞—è –ú–∞–Ω—Ö—ç—Ç—Ç–µ–Ω-–ª–∏–Ω–∏—è –ø–æ X –∏–ª–∏ Y\n        if a.x == b.x:\n            step = 1 if b.y > a.y else -1\n            for y in range(a.y + step, b.y, step):\n                if Position(a.x, y) in self.obstacles:\n                    return True\n        elif a.y == b.y:\n            step = 1 if b.x > a.x else -1\n            for x in range(a.x + step, b.x, step):\n                if Position(x, a.y) in self.obstacles:\n                    return True\n        return False\n\n    def apply_zone_effects(self, state: 'GameState') -> None:\n        \"\"\"–ö–∞–∂–¥—ã–π —Ç–∏–∫ –≤ regen_zone: +1 HP –∂–∏–≤—ã–º —é–Ω–∏—Ç–∞–º.\"\"\"\n        for u in state.units.values():\n            if u.pos in self.regen_zone and u.is_alive():\n                u.hp = min(u.profile.max_hp, u.hp + 1)\n"
      },
      "core.md": {
        "path": "src/domain/core/core.md",
        "content": "# üß© Domain Core Overview\n\n**`src/domain/core/`** ‚Äî —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π —Å–ª–æ–π –¥–æ–º–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏, –æ—Ç–≤–µ—á–∞—é—â–∏–π –∑–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –∫–ª—é—á–µ–≤—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π –∏–≥—Ä–æ–≤–æ–π –ª–æ–≥–∏–∫–∏: —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π, —ç—Ñ—Ñ–µ–∫—Ç–æ–≤, –¥–æ—Å–∫–∏, —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã –∏ –∞–∫—Ç–∏–≤–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π.\n\n---\n\n## –ú–æ–¥—É–ª–∏ –∏ –∫–ª–∞—Å—Å—ã\n\n### 1. `ability.py` ‚Äî **–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ (Abilities)**\n\n```python\n@dataclass(frozen=True, slots=True)\nclass Ability:\n    name: str                # –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä (–Ω–∞–ø—Ä–∏–º–µ—Ä, \"fireball\")\n    range: int               # –î–∞–ª—å–Ω–æ—Å—Ç—å –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è\n    cost: int                # –°—Ç–æ–∏–º–æ—Å—Ç—å –≤ AP\n    target: TargetType       # –¢–∏–ø —Ü–µ–ª–∏: SELF, ENEMY, ALLY –∏ –¥—Ä.\n    effects: FrozenSet[Effect]  # –ù–∞–±–æ—Ä —ç—Ñ—Ñ–µ–∫—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç –∞–±–∏–ª–∫–∞\n    cast_time: int = 1       # –°–∫–æ–ª—å–∫–æ —Ç–∏–∫–æ–≤ –¥–ª–∏—Ç—Å—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ\n    aoe: int = 0             # –†–∞–¥–∏—É—Å –¥–µ–π—Å—Ç–≤–∏—è (0 ‚Äî –æ–¥–Ω–æ—Ü–µ–ª–µ–≤–∞—è)\n    bounces: int = 0         # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ \"–ø—Ä—ã–∂–∫–æ–≤\" (–¥–ª—è —Ü–µ–ø–Ω—ã—Ö —É–º–µ–Ω–∏–π)\n    bounce_mult: float = 1.0 # –ú–Ω–æ–∂–∏—Ç–µ–ª—å —Å–∏–ª—ã –ø—Ä—ã–∂–∫–∞\n–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ:\n–û–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, \"melee_attack\", \"move_to\", \"fireball\"). –ê–±–∏–ª–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —Å–∏–º—É–ª—è—Ü–∏–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è.\n\n2. action.py ‚Äî –ê–∫—Ç–∏–≤–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è (Active Actions)\npython\nCopy\nEdit\n@dataclass\nclass ActiveAction:\n    ability: Ability\n    target: Position\n    ticks_remaining: int\n    path: Optional[List[Position]] = None\n    target_unit_id: Optional[int] = None\n    started: bool = False\n\n    def tick(self) -> bool:\n        self.ticks_remaining -= 1\n        return self.ticks_remaining <= 0\n–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ:\n–•—Ä–∞–Ω–∏—Ç —Ç–µ–∫—É—â–µ–µ \"–ø—Ä–æ–∏—Å—Ö–æ–¥—è—â–µ–µ\" –¥–µ–π—Å—Ç–≤–∏–µ —é–Ω–∏—Ç–∞: –∫–∞–∫—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –æ–Ω –∫–∞—Å—Ç—É–µ—Ç, –ø–æ –∫–∞–∫–æ–π —Ü–µ–ª–∏, —Å–∫–æ–ª—å–∫–æ —Ç–∏–∫–æ–≤ –æ—Å—Ç–∞–ª–æ—Å—å, –∫–∞–∫–æ–π –ø—É—Ç—å –∏–¥—ë—Ç (–¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è), –Ω–∞—á–∞—Ç–æ –ª–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ.\n–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø–æ—ç—Ç–∞–ø–Ω–æ–≥–æ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —Å–ª–æ–∂–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π (–¥–≤–∏–∂–µ–Ω–∏–µ, –¥–ª–∏—Ç–µ–ª—å–Ω—ã–µ –∫–∞—Å—Ç—ã).\n\n3. board.py ‚Äî –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ (Board)\npython\nCopy\nEdit\n@dataclass(slots=True)\nclass Board:\n    obstacles: Set[Position] = field(default_factory=set)\n    regen_zone: Set[Position] = field(default_factory=set)\n\n    def is_blocked(self, pos: Position) -> bool\n    def is_line_blocked(self, a: Position, b: Position) -> bool\n    def apply_zone_effects(self, state: 'GameState') -> None\n–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ:\n–ü—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –∫–∞—Ä—Ç—É —É—Ä–æ–≤–Ω—è:\n\nobstacles ‚Äî –∫–ª–µ—Ç–∫–∏-—Å—Ç–µ–Ω—ã, –ø–æ –∫–æ—Ç–æ—Ä—ã–º –Ω–µ–ª—å–∑—è –ø—Ä–æ–π—Ç–∏/–ø—Ä–æ—Å—Ç—Ä–µ–ª–∏—Ç—å.\n\nregen_zone ‚Äî –∫–ª–µ—Ç–∫–∏, –Ω–∞ –∫–æ—Ç–æ—Ä—ã—Ö –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è HP.\n\n–ú–µ—Ç–æ–¥—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, –º–æ–∂–Ω–æ –ª–∏ –ø—Ä–æ–π—Ç–∏/–ø—Ä–æ—Å—Ç—Ä–µ–ª–∏—Ç—å –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏, –∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∑–æ–Ω–∞–ª—å–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤.\n\n4. effect.py ‚Äî –≠—Ñ—Ñ–µ–∫—Ç—ã (Effects)\npython\nCopy\nEdit\n@dataclass(frozen=True, slots=True)\nclass Effect:\n    type: EffectType    # –¢–∏–ø —ç—Ñ—Ñ–µ–∫—Ç–∞ (DAMAGE, HEAL, SHIELD –∏ –¥—Ä.)\n    value: int          # –ó–Ω–∞—á–µ–Ω–∏–µ (—Å–∫–æ–ª—å–∫–æ HP –ª–µ—á–∏—Ç/—Å–Ω–∏–º–∞–µ—Ç, —Å–∏–ª–∞ —â–∏—Ç–∞ –∏ –¥—Ä.)\n    duration: int       # –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (–≤ —Ç–∏–∫–∞—Ö)\n–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ:\n–ö–ª–∞—Å—Å –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –æ–¥–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ (—É—Ä–æ–Ω, —â–∏—Ç, –∑–∞–º–µ–¥–ª–µ–Ω–∏–µ –∏ –¥—Ä.), –∫–æ—Ç–æ—Ä—ã–π –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç—Å—è –∞–±–∏–ª–∫–æ–π –Ω–∞ —Ü–µ–ª—å.\n\n5. state.py ‚Äî –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã (GameState)\npython\nCopy\nEdit\n@dataclass(slots=True)\nclass GameState:\n    tick: int\n    units: Dict[int, HeroUnit]\n    board: Board\n\n    def clear_temporary(self) -> None\n    def get_unit_at(self, pos)\n    def is_game_over(self) -> bool\n–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ:\n\n–ü—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –≤—Å—é –∏–≥—Ä–æ–≤—É—é \"–∫–∞—Ä—Ç–∏–Ω—É\": –∫—Ç–æ –∂–∏–≤, –∫—Ç–æ –≥–¥–µ —Å—Ç–æ–∏—Ç, –∫–∞–∫–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è.\n\n–•—Ä–∞–Ω–∏—Ç –≤—Å–µ —é–Ω–∏—Ç—ã (units) –∏ –∏–≥—Ä–æ–≤—É—é –¥–æ—Å–∫—É (board).\n\n–ú–µ—Ç–æ–¥—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ —é–Ω–∏—Ç—É –ø–æ –ø–æ–∑–∏—Ü–∏–∏ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã.\n\n–í–∑–∞–∏–º–æ—Å–≤—è–∑–∏\nAbility –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ ActiveAction (–∫–∞–∫—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –∫–∞—Å—Ç—É–µ—Ç —é–Ω–∏—Ç).\n\nEffect —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ Ability (—á—Ç–æ –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç –ø—Ä–∏ –∫–∞—Å—Ç–µ).\n\nBoard –∏ GameState –æ—Ç–≤–µ—á–∞—é—Ç –∑–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—è –∏ –æ–±—ä–µ–∫—Ç–æ–≤.\n\nGameState —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ —é–Ω–∏—Ç—ã (HeroUnit) –∏ –¥–æ—Å–∫—É (Board).\n\nActiveAction (—É —é–Ω–∏—Ç–∞) ‚Äî –∫–ª—é—á–µ–≤–æ–π –¥–ª—è —Å–∏–º—É–ª—è—Ü–∏–∏ –º–µ—Ö–∞–Ω–∏–∑–º \"—á—Ç–æ —Å–µ–π—á–∞—Å –¥–µ–ª–∞–µ—Ç —é–Ω–∏—Ç\".\n\n–î–ª—è —á–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–∏ –∫–ª–∞—Å—Å—ã?\nAbility ‚Äî –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–∞ –∏–ª–∏ –∏–Ω–∞—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å.\n\nActiveAction ‚Äî –µ—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∑–Ω–∞—Ç—å, —á—Ç–æ —Å–µ–π—á–∞—Å –¥–µ–ª–∞–µ—Ç —é–Ω–∏—Ç –∏ —Å–∫–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–∏ –æ—Å—Ç–∞–ª–æ—Å—å.\n\nBoard ‚Äî –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, –º–æ–∂–Ω–æ –ª–∏ —Ö–æ–¥–∏—Ç—å/—Å—Ç—Ä–µ–ª—è—Ç—å –ø–æ –∫–ª–µ—Ç–∫–µ.\n\nEffect ‚Äî —á—Ç–æ–±—ã –Ω–∞–≤–µ—Å–∏—Ç—å/—Å–Ω—è—Ç—å —ç—Ñ—Ñ–µ–∫—Ç—ã —Å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞.\n\nGameState ‚Äî –æ—Å–Ω–æ–≤–Ω–∞—è —Ç–æ—á–∫–∞ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–æ—Å—Ç–æ—è–Ω–∏—é –∏–≥—Ä—ã –≤ –ª—é–±–æ–º —Ç–∏–∫–µ.\n\n–í—Å–µ —ç—Ç–∏ –∫–ª–∞—Å—Å—ã –Ω–µ —Å–æ–¥–µ—Ä–∂–∞—Ç –ª–æ–≥–∏–∫–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è (–∫—Ä–æ–º–µ –º–µ—Ç–æ–¥–æ–≤ –¥–æ—Å—Ç—É–ø–∞ –∏ –ø—Ä–æ—Å—Ç—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π) –∏ –æ–±—Ä–∞–∑—É—é—Ç —á–∏—Å—Ç—É—é, –Ω–µ–∑–∞–≤–∏—Å–∏–º—É—é –¥–æ–º–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å. –í—Å—è \"–º–∞–≥–∏—è\" —Å–∏–º—É–ª—è—Ü–∏–∏ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ engine ‚Äî —ç—Ç–∏ –∫–ª–∞—Å—Å—ã –ª–∏—à—å –µ—ë –æ–ø–∏—Å—ã–≤–∞—é—Ç.\n\n# üì¶ src/domain/core ‚Äî –ú–æ–¥–µ–ª—å —é–Ω–∏—Ç–∞ –∏ —Å—Ç–∞—Ç—ã\n\n## –ú–æ–¥—É–ª—å `unit_stats.py`\n–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –±–∞–∑–æ–≤—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –ª—é–±–æ–≥–æ —é–Ω–∏—Ç–∞ (–Ω–µ –∏–≥—Ä–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –∞ \"–ø–∞—Å–ø–æ—Ä—Ç\"):\n\n```python\n@dataclass(frozen=True, slots=True)\nclass UnitStats:\n    \"\"\"\n    –ë–∞–∑–æ–≤—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ —é–Ω–∏—Ç–∞:\n      - hp_max       ‚Äî –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–¥–æ—Ä–æ–≤—å–µ\n      - move_range   ‚Äî —Å–∫–æ–ª—å–∫–æ –∫–ª–µ—Ç–æ–∫ –º–æ–∂–µ—Ç –ø—Ä–æ–π—Ç–∏ –∑–∞ 1 AP\n      - block_chance ‚Äî —à–∞–Ω—Å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —á–∞—Å—Ç—å —É—Ä–æ–Ω–∞ (0-100%)\n      - max_ap       ‚Äî —Å–∫–æ–ª—å–∫–æ AP —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç—Å—è –≤ –Ω–∞—á–∞–ª–µ —Ö–æ–¥–∞\n    \"\"\"\n    hp_max: int\n    move_range: int = 1\n    block_chance: int = 0\n    max_ap: int = MAX_AP\n–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –ø—Ä–æ—Ñ–∏–ª–µ –≥–µ—Ä–æ—è, —á—Ç–æ–±—ã –±—ã—Å—Ç—Ä–æ –∏ —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ –æ–ø–∏—Å—ã–≤–∞—Ç—å –≤—Å–µ \"–ø–æ—Å—Ç–æ—è–Ω–Ω—ã–µ\" –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —é–Ω–∏—Ç–∞.\n\n–ú–æ–¥—É–ª—å unit.py\n–Ø–¥—Ä–æ –º–æ–¥–µ–ª–∏ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞: HeroUnit.\n\n–û—Å–Ω–æ–≤–Ω—ã–µ –∞—Å–ø–µ–∫—Ç—ã:\n–•—Ä–∞–Ω–∏—Ç –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —é–Ω–∏—Ç–∞ (HP, AP, –ø–æ–∑–∏—Ü–∏—è, —ç—Ñ—Ñ–µ–∫—Ç—ã, —Ç–µ–∫—É—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ).\n\n–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä–∞–±–æ—Ç—É —Å \"–±–æ–µ–≤—ã–º–∏\" –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏ —á–µ—Ä–µ–∑ combat-–º–æ–¥—É–ª—å.\n\n–†–µ–∞–ª–∏–∑—É–µ—Ç –ª–æ–≥–∏–∫—É —Å—Ç–∞—Ä—Ç–∞ –∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è —Å –∞–≤—Ç–æ–ø–æ–≤—Ç–æ—Ä–æ–º.\n\n–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–Ω–æ–≤–æ —Å—Ç–∞–≤–∏—Ç –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ—Å–ª–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è (–¥–æ override).\n\n–†–∞–±–æ—Ç–∞–µ—Ç —Å pathfinding –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è.\n\n–ò—Å–ø–æ–ª—å–∑—É–µ—Ç –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—é: —É—Ä–æ–Ω, –ª–µ—á–µ–Ω–∏–µ, —ç—Ñ—Ñ–µ–∫—Ç—ã ‚Äî –≤ combat.\n\npython\nCopy\nEdit\n@dataclass(slots=True)\nclass HeroUnit:\n    id: int\n    role: UnitRole\n    team: TeamId\n    pos: Position\n    profile: CharacterProfile\n    hp: int = field(init=False)\n    ap: int = field(init=False)\n    effects: list[Effect] = field(default_factory=list, init=False)\n    current_action: Optional[ActiveAction] = field(default=None, init=False)\n    ...\n–ö–ª—é—á–µ–≤—ã–µ –º–µ—Ç–æ–¥—ã:\ntick_effects ‚Äî —É–º–µ–Ω—å—à–∞–µ—Ç –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —ç—Ñ—Ñ–µ–∫—Ç–æ–≤, —É–¥–∞–ª—è—è –∏—Å—Ç—ë–∫—à–∏–µ.\n\napply_ap_regen ‚Äî –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç AP –ø–æ –ø—Ä–æ—Ñ–∏–ª—é.\n\napply_damage/apply_heal/add_effect ‚Äî –±—ã—Å—Ç—Ä—ã–π –¥–æ—Å—Ç—É–ø –∫ –±–æ–µ–≤—ã–º –æ–ø–µ—Ä–∞—Ü–∏—è–º (–¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç combat-–º–æ–¥—É–ª—é).\n\nstart_action ‚Äî –Ω–∞—á–∏–Ω–∞–µ—Ç –Ω–æ–≤–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ (–µ—Å–ª–∏ –Ω–µ –∫–∞—Å—Ç—É–µ—Ç —á—Ç–æ-—Ç–æ).\n\nadvance_action ‚Äî —Ä–µ–∞–ª–∏–∑—É–µ—Ç –æ—Å–Ω–æ–≤–Ω–æ–π –∂–∏–∑–Ω–µ–Ω–Ω—ã–π —Ü–∏–∫–ª: –¥–≤–∏–∂–µ–Ω–∏–µ, –∫–∞—Å—Ç—ã, –ø–æ–≤—Ç–æ—Ä.\n\n–¢–∏–ø–∏—á–Ω—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:\nUnitStats ‚Äî –∫–æ–≥–¥–∞ –Ω–∞–¥–æ –ø–æ–ª—É—á–∏—Ç—å/–∑–∞–¥–∞—Ç—å –±–∞–∑–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –Ω–µ –∑–∞–≤–∏—Å—è—â–∏–µ –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–æ—è.\n\nHeroUnit ‚Äî –≤—Å–µ–≥–¥–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ –∏–≥—Ä–æ–≤–æ–º—É —é–Ω–∏—Ç—É –≤ GameState.\n\n–û—Ç–ª–∏—á–∏–µ:\nUnitStats ‚Äî –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–π –Ω–∞–±–æ—Ä —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ (\"–ø—Ä–æ—Ñ–∏–ª—å\" —é–Ω–∏—Ç–∞, –∞–Ω–∞–ª–æ–≥ D&D stat block).\n\nHeroUnit ‚Äî –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ, –∏–∑–º–µ–Ω—è–µ–º–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —é–Ω–∏—Ç–∞ –Ω–∞ –∫–∞—Ä—Ç–µ (HP, AP, —ç—Ñ—Ñ–µ–∫—Ç—ã, –ø–æ–∑–∏—Ü–∏—è, —Ç–µ–∫—É—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ).\n\n–í–∞–∂–Ω—ã–µ –∑–∞–º–µ—á–∞–Ω–∏—è:\n–ë–æ–µ–≤–∞—è –ª–æ–≥–∏–∫–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤—ã–≤–µ–¥–µ–Ω–∞ –≤ combat-–º–æ–¥—É–ª—å –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏.\n\n–í—Å–µ –¥–µ–π—Å—Ç–≤–∏—è —é–Ω–∏—Ç–∞ (–∫–∞—Å—Ç, –¥–≤–∏–∂–µ–Ω–∏–µ, –æ–∂–∏–¥–∞–Ω–∏–µ) –¥–æ–ª–∂–Ω—ã –∏–¥—Ç–∏ —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ advance_action.\n\ncurrent_action –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è, –ø–æ–∫–∞ –Ω–µ –±—É–¥–µ—Ç –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω–æ –Ω–æ–≤—ã–º –∏–Ω—Ç–µ–Ω—Ç–æ–º."
      },
      "effect.py": {
        "path": "src/domain/core/effect.py",
        "content": "from dataclasses import dataclass\nfrom ..enums import EffectType\n\n@dataclass(frozen=True, slots=True)\nclass Effect:\n    \"\"\"\n    –ê–∫—Ç–∏–≤–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –Ω–∞ —é–Ω–∏—Ç–µ:\n      - type      - —Ç–∏–ø —ç—Ñ—Ñ–µ–∫—Ç–∞ (SLOW_AP, SHIELD –∏ —Ç.–¥.)\n      - value     - –≤–µ–ª–∏—á–∏–Ω–∞ (—Å–∫–æ–ª—å–∫–æ AP —Å–Ω–∏–º–∞–µ—Ç, —Ä–∞–∑–º–µ—Ä —â–∏—Ç–∞‚Ä¶)\n      - duration  - —Å–∫–æ–ª—å–∫–æ –µ—â—ë —Ö–æ–¥–æ–≤ –¥–µ–π—Å—Ç–≤—É–µ—Ç\n    \"\"\"\n    type: EffectType\n    value: int\n    duration: int\n"
      },
      "state.py": {
        "path": "src/domain/core/state.py",
        "content": "from dataclasses import dataclass\nfrom typing import Dict\nfrom .unit import HeroUnit\nfrom .board import Board\n\n\n@dataclass(slots=True)\nclass GameState:\n    \"\"\"\n    –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã:\n      - tick           ‚Äî –Ω–æ–º–µ—Ä —Ç–∏–∫–∞\n      - units          ‚Äî —Å–ª–æ–≤–∞—Ä—å id‚ÜíHeroUnit\n      - board          ‚Äî —ç–∫–∑–µ–º–ø–ª—è—Ä Board\n    \"\"\"\n    tick: int\n    units: Dict[int, HeroUnit]\n    board: Board\n\n    def clear_temporary(self) -> None:\n        for u in self.units.values():\n            u.clear_queue()\n            u.tick_effects()\n\n    def get_unit_at(self, pos):\n        for u in self.units.values():\n            if u.pos == pos and u.is_alive():\n                return u\n        return None\n\n    def is_game_over(self) -> bool:\n        teams = {u.team for u in self.units.values() if u.is_alive()}\n        return len(teams) <= 1\n\n"
      },
      "stats.py": {
        "path": "src/domain/core/stats.py",
        "content": "from dataclasses import dataclass\nfrom ..constants import MAX_AP\n\n@dataclass(frozen=True, slots=True)\nclass UnitStats:\n    \"\"\"\n    –ë–∞–∑–æ–≤—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ —é–Ω–∏—Ç–∞:\n      - hp_max       - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–¥–æ—Ä–æ–≤—å–µ\n      - move_range   - —Å–∫–æ–ª—å–∫–æ –∫–ª–µ—Ç–æ–∫ –º–æ–∂–µ—Ç –ø—Ä–æ–π—Ç–∏ –∑–∞ 1 AP\n      - block_chance - —à–∞–Ω—Å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —á–∞—Å—Ç—å —É—Ä–æ–Ω–∞ (0-100%)\n      - max_ap       - —Å–∫–æ–ª—å–∫–æ AP —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç—Å—è –≤ –Ω–∞—á–∞–ª–µ —Ö–æ–¥–∞\n    \"\"\"\n    hp_max: int\n    move_range: int = 1\n    block_chance: int = 0\n    max_ap: int = MAX_AP\n"
      },
      "unit.py": {
        "path": "src/domain/core/unit.py",
        "content": "# src/domain/core/unit.py\n\nfrom dataclasses import dataclass, field\nfrom typing import Optional, Iterable\n\nfrom domain.engine.combat import add_effect_to_unit, apply_damage_to_unit, apply_heal_to_unit, calculate_damage\nfrom domain.geometry.pathfinding import find_path\n\nfrom ..constants import TeamId\nfrom ..enums import EffectType, UnitRole\nfrom ..geometry.position import Position\nfrom .ability import Ability\nfrom .effect import Effect\nfrom ..heroes.profile import CharacterProfile\nfrom .action import ActiveAction\nfrom config.logger import RTS_Logger\n\n\nlogger = RTS_Logger()\n\n\n@dataclass(slots=True)\nclass HeroUnit:\n    id: int\n    role: UnitRole\n    team: TeamId\n    pos: Position\n\n    profile: CharacterProfile\n\n    hp: int =   field(init=False)\n    ap: int =   field(init=False)\n    luck: int = field(init=False)\n    effects: list[Effect] = field(default_factory=list, init=False)\n\n    # single in‚Äêflight action\n    current_action: Optional[ActiveAction] = field(default=None, init=False)\n    # –ù–æ–≤–æ–µ –ø–æ–ª–µ: –∫–∞–∫–∞—è ability –±—ã–ª–∞ —Ä–µ–∞–ª—å–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–º —Ç–∏–∫–µ\n    completed_action: Optional[ActiveAction] = field(default=None, init=False)\n\n    def __post_init__(self):\n        self.hp     = self.profile.max_hp\n        self.ap     = self.profile.max_ap\n        self.luck   = self.profile.luck\n\n    def is_alive(self) -> bool:\n        return self.hp > 0\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self.profile.abilities\n\n    @property\n    def luck(self) -> int:\n        return self.profile.luck\n    \n    def tick_effects(self) -> None:\n        remaining = []\n        for eff in self.effects:\n            new_duration = eff.duration - 1\n            if new_duration > 0:\n                # —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π Effect (copy with duration-1)\n                new_eff = Effect(eff.type, eff.value, new_duration)\n                remaining.append(new_eff)\n        self.effects = remaining\n\n    def apply_ap_regen(self) -> None:\n        \"\"\"\n        Regenerate AP taking into account SLOW_AP debuffs and AP_BOOST buffs.\n        \"\"\"\n        base_regen: int = self.profile.ap_regen\n        slow_amount: int = sum(e.value for e in self.effects if e.type is EffectType.SLOW_AP)\n        boost_amount: int = sum(e.value for e in self.effects if e.type is EffectType.AP_BOOST)\n\n        regen: int = max(0, base_regen - slow_amount + boost_amount)\n        self.ap = min(self.profile.max_ap, self.ap + regen)\n\n    # ‚îÄ‚îÄ‚îÄ combat shortcuts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n    def apply_damage(self, amount: int) -> int:\n        return apply_damage_to_unit(self, amount)\n\n    def apply_heal(self, amount: int) -> int:\n        return apply_heal_to_unit(self, amount)\n\n    def add_effect(self, effect: Effect) -> None:\n        add_effect_to_unit(self, effect)\n    \n    def calculate_damage(self, ability: Ability) -> int:\n        return calculate_damage(self, ability)\n    # ‚îÄ‚îÄ‚îÄ action management ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n    def start_action(\n        self,\n        ability: Ability,\n        target: Optional[Position],\n        state: \"GameState\",\n        target_unit_id: Optional[int] = None\n    ) -> None:\n        \"\"\"\n        Begin a new action, even if one is in progress (unless it's casting).\n        \"\"\"\n        prev = self.current_action\n        if prev and getattr(prev, \"started\", False):\n            # if in the middle of a cast, don't override\n            raise RuntimeError(\"Cannot override a casting action\")\n        logger.log_lvl3(f\"[start_action] Unit {self.id} ‚áí '{ability.name}' @ {target or target_unit_id}\")\n        self.current_action = ActiveAction(\n            ability=ability,\n            target=target,\n            target_unit_id=target_unit_id,\n            ticks_remaining=ability.cast_time,\n            path=None,\n            started=False\n        )\n\n    def advance_action(self, state: \"GameState\") -> Optional[ActiveAction]:\n        \"\"\"\n        Execute the current_action one tick:\n          1) If casting already started ‚Üí tick down\n          2) Else if it's a movement ability ‚Üí walk/sprint along path (no stepping onto occupied cells)\n          3) Else if in range & have AP ‚Üí begin cast\n          4) Else if out of range & have AP ‚Üí step closer\n          5) Else wait.\n        After an action completes, *re-queues* it until overridden.\n        Returns the completed ActiveAction once, else None.\n        \"\"\"\n        act = self.current_action\n        if not act:\n            return None\n\n        ab = act.ability\n        name = ab.name.lower()\n\n        # determine current target position\n        if act.target_unit_id is not None:\n            tgt_u = state.units.get(act.target_unit_id)\n            if not tgt_u or not tgt_u.is_alive():\n                self.current_action = None\n                return None\n            tgt_pos = tgt_u.pos\n        else:\n            tgt_pos = act.target\n\n        # 1) ongoing cast?\n        if getattr(act, \"started\", False):\n            done = act.tick()\n            if done:\n                self.completed_action = act\n                logger.log_lvl2(f\"Unit {self.id} finished cast '{ab.name}'\")\n                completed = act\n                self.current_action = ActiveAction(\n                    ability=ab,\n                    target=act.target,\n                    target_unit_id=act.target_unit_id,\n                    ticks_remaining=ab.cast_time,\n                    path=None,\n                    started=False\n                )\n                return completed\n            return None\n\n        # 2) movement abilities\n        if name in (\"move_to\", \"sprint\"):\n            if act.path is None:\n                act.path = find_path(self.pos, tgt_pos, state)\n            if not act.path:\n                return None\n\n            step_len = ab.range\n            moved = 0\n            while moved < step_len and self.ap > 0 and act.path:\n                next_pos = act.path[0]\n                occupant = state.get_unit_at(next_pos)\n                if occupant and occupant.is_alive() and occupant.id != self.id:\n                    logger.log_lvl2(f\"Unit {self.id} movement blocked at {next_pos} by unit {occupant.id}\")\n                    break\n                self.pos = act.path.pop(0)\n                self.ap -= 1\n                moved += 1\n\n            if not act.path or self.pos == tgt_pos:\n                logger.log_lvl2(f\"Unit {self.id} reached move target {tgt_pos}\")\n                completed = act\n                self.current_action = ActiveAction(\n                    ability=ab,\n                    target=act.target,\n                    target_unit_id=act.target_unit_id,\n                    ticks_remaining=ab.cast_time,\n                    path=None,\n                    started=False\n                )\n                return completed\n            return None\n\n        # 3) can start cast?\n        if self.ap >= ab.cost and (name == \"sprint\" or self.pos.distance(tgt_pos) <= ab.range):\n            self.ap -= ab.cost\n            act.started = True\n            done = act.tick()\n            if done:\n                self.completed_action = act\n                logger.log_lvl2(f\"Unit {self.id} instant '{ab.name}'\")\n                completed = act\n                self.current_action = ActiveAction(\n                    ability=ab,\n                    target=act.target,\n                    target_unit_id=act.target_unit_id,\n                    ticks_remaining=ab.cast_time,\n                    path=None,\n                    started=False\n                )\n                return completed\n            return None\n\n        # 4) step closer if out of range & have AP\n        if self.ap > 0 and self.pos.distance(tgt_pos) > ab.range:\n            path = find_path(self.pos, tgt_pos, state)\n            if path:\n                next_pos = path[0]\n                occupant = state.get_unit_at(next_pos)\n                if not (occupant and occupant.is_alive() and occupant.id != self.id):\n                    self.pos = next_pos\n                    self.ap -= 1\n            return None\n\n        # 5) no AP ‚Üí wait\n        return None\n"
      }
    },
    "geometry": {
      "README.md": {
        "path": "src/domain/geometry/README.md",
        "content": ""
      },
      "__init__.py": {
        "path": "src/domain/geometry/__init__.py",
        "content": ""
      },
      "pathfinding.py": {
        "path": "src/domain/geometry/pathfinding.py",
        "content": "# src/domain/geometry/pathfinding.py\n\nfrom collections import deque\nfrom typing import List, Dict\n\nfrom ..geometry.position import Position\nfrom config.logger import RTS_Logger\n\nlogger = RTS_Logger()\n\n\nDIRECTIONS_8 = [\n    (1, 0), (-1, 0), (0, 1), (0, -1),\n    (1, 1), (1, -1), (-1, 1), (-1, -1)\n]\n\ndef find_path(start: Position, goal: Position, state: \"GameState\") -> List[Position]:\n    \"\"\"\n    BFS: –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø–æ–∑–∏—Ü–∏–π –æ—Ç start (–Ω–µ –≤–∫–ª—é—á–∞—è) –¥–æ goal (–≤–∫–ª—é—á–∞—è),\n    –æ–±—Ö–æ–¥—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è –∏ –∑–∞–Ω—è—Ç—ã–µ –∫–ª–µ—Ç–∫–∏.\n    –ï—Å–ª–∏ –ø—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç [].\n    \"\"\"\n    logger.log_lvl3(f\"[find_path] start={start}, goal={goal}\")\n    if start == goal:\n        logger.log_lvl3(\"[find_path] start == goal, empty path.\")\n        return []\n\n    visited = {start}\n    prev: Dict[Position, Position] = {}\n    q = deque([start])\n\n    while q:\n        cur = q.popleft()\n        for dx, dy in DIRECTIONS_8:\n            nxt = Position(cur.x + dx, cur.y + dy)\n            if not nxt.in_bounds():\n                continue\n            if state.board.is_blocked(nxt):\n                continue\n            occ = state.get_unit_at(nxt)\n            if occ and nxt != goal:\n                continue\n            if nxt in visited:\n                continue\n            # (MVP: –º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —É–≥–ª–æ–≤—É—é –ø—Ä–æ–≤–µ—Ä–∫—É)\n            visited.add(nxt)\n            prev[nxt] = cur\n            if nxt == goal:\n                path = [goal]\n                while path[-1] != start:\n                    path.append(prev[path[-1]])\n                return list(reversed(path))[1:]\n            q.append(nxt)\n            \n    logger.log_lvl2(f\"[find_path] No path found from {start} to {goal}\")\n    return []\n"
      },
      "position.py": {
        "path": "src/domain/geometry/position.py",
        "content": "from dataclasses import dataclass\nfrom ..constants import BOARD_SIZE\n\n@dataclass(frozen=True, slots=True)\nclass Position:\n    x: int; y: int\n    def distance(self, other) -> int:\n        if isinstance(other, Position):\n            return max(abs(self.x - other.x), abs(self.y - other.y))\n        if hasattr(other, \"pos\"):\n            return max(abs(self.x - other.pos.x), abs(self.y - other.pos.y))\n        else:\n            raise TypeError(f\"manhattan: expected Position or object with .pos, got {type(other)}\")\n    \n    def in_bounds(self) -> bool:\n        return 0 <= self.x < BOARD_SIZE and 0 <= self.y < BOARD_SIZE\n"
      }
    }
  },
  "interfaces": {
    "cli.py": {
      "path": "src/interfaces/cli.py",
      "content": "import argparse\nimport sys\nfrom config.cli_config import cli_settings\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(prog=\"turnshock\")\n    parser.add_argument(\n        \"--renderer\",\n        choices=[\"text\", \"pygame\"],\n        default=\"pygame\",\n        help=\"–í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞ –≤—ã–≤–æ–¥–∞: —Ç–µ–∫—Å—Ç–æ–≤—ã–π CLI –∏–ª–∏ Pygame\"\n    )\n    args = parser.parse_args()\n\n    if args.renderer == \"pygame\":\n        from ui.pygame.app import PyGameApp\n\n        PyGameApp(\n            width=cli_settings.screen_w,\n            height=cli_settings.screen_h,\n            cell=cli_settings.cell_size,\n        ).run()\n    else:\n        print(\"–¢–µ–∫—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω.\")\n        sys.exit(0)\n\nif __name__ == \"__main__\":\n    main()"
    }
  }
}