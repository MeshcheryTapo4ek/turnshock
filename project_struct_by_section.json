{
  "application": {
    "__init__.py": {
      "path": "src/application/__init__.py",
      "content": ""
    },
    "game_generator.py": {
      "path": "src/application/game_generator.py",
      "content": "# relative path: src/application/game_generator.py\n\nimport random\nfrom pathlib import Path\nfrom typing import Iterator, Callable, Optional, List\n\nfrom config.config_loader import load_map_config, load_hero_setup\nfrom config.cli_config import cli_settings\nfrom domain.factory.game_factory import build_new_game\n\n\nclass GeneratorConfig:\n    \"\"\"\n    Конфиг для генератора игр:\n      - scenarios_dir: папка с подпапками-сценариями\n      - mode: \"sequential\" или \"random\"\n      - loop: зациклить ли после конца\n      - filter_fn: опциональный фильтр по имени сценария\n    \"\"\"\n    def __init__(\n        self,\n        scenarios_dir: Path,\n        mode: str = \"sequential\",\n        loop: bool = True,\n        filter_fn: Optional[Callable[[str], bool]] = None\n    ):\n        self.scenarios_dir = scenarios_dir\n        self.mode = mode\n        self.loop = loop\n        self.filter_fn = filter_fn\n\ndef build_generator_config_from_cli() -> GeneratorConfig:\n    \"\"\"\n    Строит GeneratorConfig по значениям из cli_settings:\n      - scenarios_dir, mode, loop\n      - count передаётся в generate_games()\n      - filter_fn — если указан scenario_name, фильтруем только его\n    \"\"\"\n    filter_fn: Optional[Callable[[str], bool]] = None\n    if cli_settings.scenario_name:\n        name = cli_settings.scenario_name\n        filter_fn = lambda n: n == name\n\n    return GeneratorConfig(\n        scenarios_dir=Path(cli_settings.scenarios_dir),\n        mode=cli_settings.mode,\n        loop=cli_settings.loop,\n        filter_fn=filter_fn\n    )\n\n\ndef generate_games(\n    cfg: GeneratorConfig,\n    count: int = -1\n) -> Iterator:\n    \"\"\"\n    Генератор, который отдаёт до `count` GameState:\n      - если count > 0 — ровно count игр, потом StopIteration\n      - если count < 0 — бесконечно (при loop=True) или до первого цикла (loop=False)\n    \"\"\"\n    # собираем список имён сценариев\n    names: List[str] = [\n        p.name\n        for p in cfg.scenarios_dir.iterdir()\n        if p.is_dir()\n    ]\n    if cfg.filter_fn:\n        names = [n for n in names if cfg.filter_fn(n)]\n    if cfg.mode == \"random\":\n        random.shuffle(names)\n\n    yielded = 0\n    first_pass = True\n    while (count < 0 and (first_pass or cfg.loop)) or (count >= 0 and yielded < count):\n        first_pass = False\n        for name in names:\n            if count >= 0 and yielded >= count:\n                return\n\n            base = cfg.scenarios_dir / name\n            map_cfg    = load_map_config(str(base / \"map.json\"))\n            heroes_cfg = load_hero_setup(str(base / \"heroes.json\"))\n\n            state = build_new_game(\n                tick=0,\n                hero_setup=heroes_cfg,\n                obstacles=map_cfg.obstacles,\n                regen_zone=map_cfg.regen_zone,\n            )\n            yield state\n            yielded += 1\n\n        if cfg.mode == \"random\":\n            random.shuffle(names)\n        if count >= 0 and yielded >= count:\n            return\n        if not cfg.loop:\n            return\n"
    },
    "services": {
      "domain_connector.py": {
        "path": "src/application/services/domain_connector.py",
        "content": "# src/adapters/domain_adapter.py\n\nfrom application.game_generator import build_generator_config_from_cli, generate_games\nfrom domain.engine.event_loop import event_tick\nfrom domain.analytics.stats import stats_tracker\n\n\nclass DomainConnector:\n    def __init__(self):\n        self._create_new_game()\n\n    def _create_new_game(self):\n        gen_cfg = build_generator_config_from_cli()\n        gen_iter = generate_games(gen_cfg, count=1)\n        self.state = next(gen_iter)\n\n    def send_intents(self, intents: dict):\n        \n        self.state, executed, is_over = event_tick(self.state, intents)\n        if is_over:\n            \n            final_stats = stats_tracker.get_stats()\n            for unit_id, u_stats in final_stats.items():\n\n                print(f\"=== Unit {unit_id} stats ===\")\n\n                for ability, ab in u_stats.by_ability.items():\n\n                    print(f\" {ability}: used {ab.uses}x, \"\n                        f\"damage→enemies={ab.damage_to_enemies}, allies={ab.damage_to_allies}, \"\n                        f\"healed={ab.healing}, effects={ab.effects_applied}\")\n            \n            stats_tracker.reset()\n            \n            self._create_new_game()\n        return executed\n\n    def get_state(self):\n        return self.state\n"
      }
    }
  },
  "config": {},
  "domain": {
    "README_DOMAIN.md": {
      "path": "src/domain/README_DOMAIN.md",
      "content": "# Tactical Micro RTS — Domain Layer\n\n\n```\ndomain/\n├── constants.py      # Размеры поля, количество тиков, тип TeamId\n├── enums.py          # все Enum‑ы (роли, эффекты, типы целей, типы Action)\n│\n├── geometry/         # Простые геометрические структуры\n│   └── position.py   # dataclass Position, метрики, in_bounds\n│\n├── core/             # «Данные без поведения»\n│   ├── stats.py      # UnitStats\n│   ├── ability.py    # Ability\n│   ├── effect.py     # Effect\n│   ├── board.py      # Board\n│   ├── unit.py       # HeroUnit\n│   └── state.py      # GameState\n│\n├── rules/            # Проверка законности\n│   ├── move.py       # legal_moves(), validate_move()\n│   └── ability.py    # legal_targets(), validate_ability()\n│\n├── engine/           # Исполнение симуляции\n│   ├── applier.py    # apply_ability()\n│   ├── ticker.py     # start_turn(), resolve_tick_effects()\n│   └── simulate.py   # simulate_turn()\n│\n└── heroes/           # Фабрики готовых юнитов\n    ├── base.py\n    ├── defender.py …\n```\n\n## Поток зависимостей\n\n```\ngeometry  ┐\nconstants ├─→ core ─→ rules ─→ engine\nenums     ┘\nheroes ─────────┘       (только к core)\n```\n\n# RTS Game Rules (Tick-based)\n\n## 1. Game Map\n- Игровое поле: квадратная сетка (по умолчанию 13x13)\n- Препятствия: нельзя пройти/стрелять сквозь\n- Зоны: баффы/реген\n\n## 2. Units\n- Каждый персонаж — отдельная сущность\n- Может быть живым или мертвым\n\n## 3. Tick Loop\n\nКаждый тик:\n1. **Обновление эффектов:**  \n    - У каждого юнита декрементируется duration всех активных эффектов\n    - Эффекты с duration=0 исчезают\n2. **Выполнение действий:**  \n    - Каждый живой юнит получает возможность сделать 1 действие (move/attack/use ability)\n    - Если действие невозможно — оно игнорируется\n    - Коллизии (например, два юнита хотят одну клетку): оба остаются на месте/оба fail\n3. **Применение эффектов клеток:**  \n    - Например, регенерация\n4. **Проверка конца игры:**  \n    - Если команда полностью уничтожена — конец игры\n    \nИнтерфейсы (CLI/React/Gym) используют только  \n`domain.engine.simulate_turn()` и фабрики из `domain.heroes`."
    },
    "__init__.py": {
      "path": "src/domain/__init__.py",
      "content": "            \n"
    },
    "constants.py": {
      "path": "src/domain/constants.py",
      "content": "from typing import Final\nfrom typing import Literal\n\nTeamId = Literal[\"A\", \"B\"]\n\nBOARD_SIZE: Final = 13\nTICKS_PER_TURN: Final = 16\nMAX_AP: Final = 16\n"
    },
    "enums.py": {
      "path": "src/domain/enums.py",
      "content": "from enum import Enum, auto\n\nclass UnitRole(Enum):\n    SWORDSMAN = auto(); SHIELD = auto(); ASSASSIN = auto()\n    ARCHER = auto(); MAGE_DPS = auto(); MAGE_SUPP = auto()\n    BARD = auto()\n\nclass EffectType(Enum):\n    DAMAGE = auto(); HEAL = auto()\n    BUFF = auto(); DEBUFF = auto()\n    SLOW_AP = auto(); AP_BOOST = auto()\n    DODGE = auto(); TAUNT = auto()\n    SHIELD = auto(); BLIND = auto()\n    BOUNCE = auto(); FUMBLE = auto()\n    CRIT_DAMAGE = auto()\n    STUN = auto()\n\nclass TargetType(Enum):\n    ENEMY = auto(); ALLY = auto()\n    DEAD_ENEMY = auto(); DEAD_ALLY = auto()\n    SELF = auto(); POINT = auto()\n\nclass ActionType(Enum):\n    USE_ABILITY = auto(); MOVE_TO = auto()\n"
    },
    "errors.py": {
      "path": "src/domain/errors.py",
      "content": "# src/domain/errors.py\n\nclass DomainError(Exception):\n    \"\"\"Базовый класс ошибок домена.\"\"\"\n    pass\n\nclass InvalidAction(DomainError):\n    \"\"\"Невалидное действие (выход за границы, не тот тип цели, недостаточно AP).\"\"\"\n    pass\n\nclass OutOfBounds(InvalidAction):\n    \"\"\"Попытка выйти за пределы поля.\"\"\"\n    pass\n\nclass InsufficientAP(InvalidAction):\n    \"\"\"Недостаточно очков действия для выполнения способности.\"\"\"\n    pass\n\nclass LineOfSightBlocked(InvalidAction):\n    \"\"\"Линия видимости заблокирована препятствием.\"\"\"\n    pass\n\nclass WrongTargetType(InvalidAction):\n    \"\"\"Цель не соответствует требованиям способности (enemy/ally/dead).\"\"\"\n    pass\n"
    },
    "heroes": {
      "README.md": {
        "path": "src/domain/heroes/README.md",
        "content": "# Пакет `heroes`\n\nСодержит фабрики `create_*` и заготовки способностей.  \nНе импортирует `rules` или `engine` — только `core`."
      },
      "archer_profile.py": {
        "path": "src/domain/heroes/archer_profile.py",
        "content": "# src/domain/heroes/archer_profile.py\n\nfrom typing import Tuple, Iterable\n\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability\n\ndef arrow_shot(dmg: int = 20, cost: int = 3, rng: int = 5) -> Ability:\n    return Ability(\n        name=\"arrow_shot\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0)\n        }),\n        cast_time=2,\n        aoe=0\n    )\n\ndef crippling_shot(\n    dmg: int = 15,\n    cost: int = 4,\n    rng: int = 4,\n    slow: int = 2,\n    duration: int = 3\n) -> Ability:\n    return Ability(\n        name=\"crippling_shot\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE,     value=dmg,  duration=0),\n            Effect(EffectType.SLOW_AP,    value=slow, duration=duration),\n        }),\n        cast_time=1,\n        aoe=0\n    )\n\ndef sand_throw(\n    chance: int = 50,\n    cost: int = 2,\n    rng: int = 2,\n    duration: int = 1\n) -> Ability:\n    return Ability(\n        name=\"sand_throw\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.BLIND, value=chance, duration=duration)\n        }),\n        cast_time=1,\n        aoe=0\n    )\n\nclass ArcherProfile(CharacterProfile):\n    def __init__(self) -> None:\n        self._max_hp        = 75\n        self._max_ap        = 16\n        self._ap_regen      = 2\n        self._luck: int     = 30\n\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            arrow_shot(dmg=20, cost=3, rng=5),\n            crippling_shot(dmg=15, cost=4, rng=4, slow=1, duration=3),\n            sand_throw(chance=50, cost=2, rng=2, duration=3),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n    \n    @property\n    def luck(self):\n        return self._luck"
      },
      "assassin_profile.py": {
        "path": "src/domain/heroes/assassin_profile.py",
        "content": "# src/domain/heroes/assassin_profile.py\n\nfrom typing import Tuple, Iterable\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability, melee_attack, sprint\nfrom .swordsman_profile import activate_dodge\n\ndef stun_strike(\n    dmg: int = 15,\n    cost: int = 4,\n    rng: int = 1,\n    duration: int = 2\n) -> Ability:\n    return Ability(\n        name=\"stun_strike\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0),\n            Effect(EffectType.STUN,   value=2,   duration=duration),\n        }),\n        cast_time=2,\n        aoe=0,\n    )\n\nclass AssassinProfile(CharacterProfile):\n    \"\"\"\n    Высокая мобильность, сильный одиночный урон и контроль:\n      - средний HP, высокий AP, отличный regen, высокий luck (шанс крита)\n      - способности: общее перемещение, базовая атака, рывок, шанс увернуться, оглушающий удар\n    \"\"\"\n    def __init__(self) -> None:\n        self._max_hp   = 60\n        self._max_ap   = 20\n        self._ap_regen = 4\n        self._luck     = 50\n\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            melee_attack(dmg=25, cost=2),\n            sprint(extra_tiles=3, cost=2),\n            activate_dodge(chance=50, duration=3, cost=3),\n            stun_strike(dmg=15, cost=4, rng=1, duration=2),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def luck(self) -> int:\n        return self._luck\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n"
      },
      "bard_profile.py": {
        "path": "src/domain/heroes/bard_profile.py",
        "content": "# src/domain/heroes/bard_profile.py\n\nfrom typing import Tuple, Iterable\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability\n\ndef chant_of_valor(\n    ap_bonus: int = 2,\n    cost: int = 4,\n    rng: int = 3,\n    aoe: int = 1,\n    duration: int = 2\n) -> Ability:\n    \"\"\"\n    Inspires nearby allies, boosting their AP regen for a few ticks.\n    \"\"\"\n    return Ability(\n        name=\"chant_of_valor\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ALLY,\n        effects=frozenset({\n            Effect(EffectType.AP_BOOST, value=ap_bonus, duration=duration)\n        }),\n        cast_time=1,\n        aoe=aoe\n    )\n\ndef dirge_of_futility(\n    slow_amount: int = 1,\n    cost: int = 5,\n    rng: int = 3,\n    aoe: int = 1,\n    duration: int = 2\n) -> Ability:\n    \"\"\"\n    Saps the will of enemies in range, slowing their AP regen.\n    \"\"\"\n    return Ability(\n        name=\"dirge_of_futility\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.SLOW_AP, value=slow_amount, duration=duration)\n        }),\n        cast_time=1,\n        aoe=aoe\n    )\n\nclass BardProfile(CharacterProfile):\n    \"\"\"\n    The Bard:\n      - moderate HP, AP, regen\n      - inspires allies and hinders enemies\n    \"\"\"\n    def __init__(self) -> None:\n        self._max_hp   = 80\n        self._max_ap   = 18\n        self._ap_regen = 3\n        self._luck     = 30\n\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            chant_of_valor(ap_bonus=2, cost=4, rng=3, aoe=1, duration=2),\n            dirge_of_futility(slow_amount=1, cost=5, rng=3, aoe=1, duration=2),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def luck(self) -> int:\n        return self._luck\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n"
      },
      "base_abilities.py": {
        "path": "src/domain/heroes/base_abilities.py",
        "content": "# src/domain/heroes/base_abilities.py\n\nfrom typing import FrozenSet\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\n\n\ndef move_to_ability(range: int = 1, cost: int = 1) -> Ability:\n    \"\"\"\n    Universal movement skill.\n    \"\"\"\n    return Ability(\n        name=\"move_to\",\n        range=range,\n        cost=cost,\n        target=TargetType.POINT,\n        effects=frozenset(),      # no effects, just movement\n        cast_time=1,\n        aoe=0,\n        bounces=0,\n        bounce_mult=1.0,\n    )\n\ndef melee_attack(dmg: int = 3, cost: int = 2) -> Ability:\n    \"\"\"\n    Universal basic attack.\n    \"\"\"\n    return Ability(\n        name=\"melee_attack\",\n        range=1,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0)\n        }),\n        cast_time=1,\n        aoe=0,\n        bounces=0,\n        bounce_mult=1.0,\n    )\n\ndef sprint(extra_tiles: int = 2, cost: int = 2) -> Ability:\n    \"\"\"\n    Selfbuff: gain extra movement tiles next tick.\n    \"\"\"\n    return Ability(\n        name=\"sprint\",\n        range=2,\n        cost=cost,\n        target=TargetType.POINT,\n        effects=frozenset({\n            Effect(EffectType.BUFF, value=extra_tiles, duration=1)\n        }),\n        cast_time=1,\n        aoe=0,\n        bounces=0,\n        bounce_mult=1.0,\n    )\n"
      },
      "defender_profile.py": {
        "path": "src/domain/heroes/defender_profile.py",
        "content": "# src/domain/heroes/defender_profile.py\n\nfrom typing import Tuple, Iterable\n\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability, melee_attack, sprint\n\ndef provoke(radius: int = 2, cost: int = 1, duration: int = 2) -> Ability:\n    return Ability(\n        name=\"provoke\",\n        range=3,\n        cost=cost,\n        target=TargetType.SELF,\n        effects=frozenset({\n            Effect(EffectType.TAUNT, value=radius, duration=duration)\n        }),\n        cast_time=2,\n        aoe=0\n    )\n\ndef slow_strike(\n    dmg: int = 15,\n    cost: int = 3,\n    slow: int = 1,\n    duration: int = 2\n) -> Ability:\n    return Ability(\n        name=\"slow_strike\",\n        range=1,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE,  value=dmg,  duration=0),\n            Effect(EffectType.SLOW_AP, value=slow, duration=duration),\n        }),\n        cast_time=1,\n        aoe=0\n    )\n\nclass DefenderProfile(CharacterProfile):\n    def __init__(self) -> None:\n        self._max_hp   = 130\n        self._max_ap   = 12\n        self._ap_regen = 1\n        self._luck: int     = 20\n\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            melee_attack(dmg=15, cost=2),\n            provoke(radius=3, cost=5, duration=3),\n            slow_strike(dmg=15, cost=3, slow=1, duration=3),\n            sprint(extra_tiles=2, cost=2),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n\n    @property\n    def luck(self):\n        return self._luck"
      },
      "mage_dps_profile.py": {
        "path": "src/domain/heroes/mage_dps_profile.py",
        "content": "# src/domain/heroes/mage_dps_profile.py\n\nfrom typing import Tuple, Iterable\n\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability\n\ndef fireball(\n    dmg: int = 30,\n    cost: int = 4,\n    rng: int = 4,\n    aoe: int = 1,\n    cast_time: int = 1\n) -> Ability:\n    \"\"\"\n    A fiery ball that explodes on impact, dealing area damage.\n    \"\"\"\n    return Ability(\n        name=\"fireball\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0)\n        }),\n        cast_time=cast_time,\n        aoe=aoe\n    )\n\ndef ice_shard(\n    dmg: int = 15,\n    cost: int = 2,\n    rng: int = 3,\n    slow: int = 1,\n    duration: int = 1,\n    cast_time: int = 1\n) -> Ability:\n    \"\"\"\n    A chilling shard that wounds and slows the target.\n    \"\"\"\n    return Ability(\n        name=\"ice_shard\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0),\n            Effect(EffectType.SLOW_AP, value=slow, duration=duration),\n        }),\n        cast_time=cast_time,\n        aoe=0\n    )\n\ndef chain_lightning(\n    dmg: int = 30,\n    bounces: int = 2,\n    bounce_mult: float = 0.5,\n    cost: int = 5,\n    rng: int = 3,\n    cast_time: int = 1\n) -> Ability:\n    \"\"\"\n    A lightning bolt that arcs between multiple enemies.\n    \"\"\"\n    return Ability(\n        name=\"chain_lightning\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({\n            Effect(EffectType.DAMAGE, value=dmg, duration=0)\n        }),\n        cast_time=cast_time,\n        aoe=3,\n        bounces=bounces,\n        bounce_mult=bounce_mult\n    )\n\nclass MageDpsProfile(CharacterProfile):\n    \"\"\"\n    Immutable profile for the DPS Mage class:\n      - low HP, full AP, moderate regen\n      - high burst damage and crowd‐control spells\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._max_hp: int   = 60\n        self._max_ap: int   = 24\n        self._ap_regen: int = 2\n        self._luck: int     = 15\n\n        # cache abilities to enforce immutability\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            fireball(dmg=30, cost=10, rng=4, aoe=1, cast_time=3),\n            ice_shard(dmg=15, cost=5, rng=3, slow=1, duration=2, cast_time=2),\n            chain_lightning(dmg=45, bounces=2, bounce_mult=0.5, cost=12, rng=2, cast_time=1),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n\n    @property\n    def luck(self):\n        return self._luck"
      },
      "mage_supp_profile.py": {
        "path": "src/domain/heroes/mage_supp_profile.py",
        "content": "# src/domain/heroes/mage_supp_profile.py\n\nfrom typing import Tuple, Iterable\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability\n\ndef mana_shield(\n    shield_hp: int = 50,\n    cost: int = 6,\n    rng: int = 5,\n    duration: int = 4\n) -> Ability:\n    \"\"\"\n    Grant an ally a temporary shield that absorbs damage.\n    \"\"\"\n    return Ability(\n        name=\"mana_shield\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ALLY,\n        effects=frozenset({\n            Effect(EffectType.SHIELD, value=shield_hp, duration=duration)\n        }),\n        cast_time=1,\n        aoe=0\n    )\n\ndef time_warp(\n    extra_ap: int = 4,\n    cost: int = 8,\n    rng: int = 2,\n    duration: int = 1\n) -> Ability:\n    \"\"\"\n    Boost an ally’s AP for a short time.\n    \"\"\"\n    return Ability(\n        name=\"time_warp\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ALLY,\n        effects=frozenset({\n            Effect(EffectType.AP_BOOST, value=extra_ap, duration=duration)\n        }),\n        cast_time=1,\n        aoe=0\n    )\n\ndef healing_wave(\n    heal_amount: int = 20,\n    cost: int = 6,\n    rng: int = 3,\n    aoe: int = 1,\n    cast_time: int = 2\n) -> Ability:\n    \"\"\"\n    A wave of restorative magic that heals all allies in an area.\n    \"\"\"\n    return Ability(\n        name=\"healing_wave\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ALLY,\n        effects=frozenset({\n            Effect(EffectType.HEAL, value=heal_amount, duration=0)\n        }),\n        cast_time=cast_time,\n        aoe=aoe\n    )\n\ndef arcane_barrier(\n    shield_hp: int = 30,\n    cost: int = 8,\n    rng: int = 3,\n    aoe: int = 1,\n    duration: int = 2\n) -> Ability:\n    \"\"\"\n    Creates a magical barrier that shields multiple allies.\n    \"\"\"\n    return Ability(\n        name=\"arcane_barrier\",\n        range=rng,\n        cost=cost,\n        target=TargetType.ALLY,\n        effects=frozenset({\n            Effect(EffectType.SHIELD, value=shield_hp, duration=duration)\n        }),\n        cast_time=2,\n        aoe=aoe\n    )\n\nclass MageSuppProfile(CharacterProfile):\n    \"\"\"\n    Immutable profile for the Support Mage:\n      - low HP, full AP pool, moderate regen\n      - specializes in shielding, AP boosts, and group healing\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._max_hp: int   = 55\n        self._max_ap: int   = 24\n        self._ap_regen: int = 3\n        self._luck: int     = 40\n\n        self._abilities: Tuple[Ability, ...] = (\n            move_to_ability(range=1, cost=1),\n            mana_shield(shield_hp=50, cost=6, rng=5, duration=4),\n            time_warp(extra_ap=4, cost=8, rng=2, duration=1),\n            healing_wave(heal_amount=20, cost=6, rng=3, aoe=1, cast_time=2),\n            arcane_barrier(shield_hp=30, cost=8, rng=3, aoe=1, duration=2),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self._abilities\n\n    @property\n    def luck(self):\n        return self._luck\n"
      },
      "profile.py": {
        "path": "src/domain/heroes/profile.py",
        "content": "# src/domain/heroes/profile.py\n\nfrom abc import ABC, abstractmethod\nfrom typing import Iterable\nfrom ..core.ability import Ability\n\nclass CharacterProfile(ABC):\n    \"\"\"\n    Value object describing immutable base parameters\n    and abilities of a hero class.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def max_hp(self) -> int:\n        \"\"\"Maximum health points.\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def max_ap(self) -> int:\n        \"\"\"Maximum action points.\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def ap_regen(self) -> int:\n        \"\"\"Action points regained per tick.\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def luck(self) -> int:\n        \"\"\"luck value.\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def abilities(self) -> Iterable[Ability]:\n        \"\"\"Base abilities available to this hero.\"\"\"\n        ...\n\n    \n"
      },
      "swordsman_profile.py": {
        "path": "src/domain/heroes/swordsman_profile.py",
        "content": "# src/domain/heroes/swordsman_profile.py\n\nfrom typing import Tuple\nfrom ..core.ability import Ability\nfrom ..core.effect import Effect\nfrom ..enums import EffectType, TargetType\nfrom .profile import CharacterProfile\nfrom .base_abilities import move_to_ability, melee_attack, sprint\n\ndef activate_dodge(chance: int = 50, duration: int = 1, cost: int = 1) -> Ability:\n    return Ability(\n        name=\"activate_dodge\",\n        range=0,\n        cost=cost,\n        target=TargetType.SELF,\n        effects=frozenset({Effect(EffectType.DODGE, chance, duration)}),\n        cast_time=2\n    )\n\ndef cleave(dmg: int = 25, duration: int = 0, cost: int = 4) -> Ability:\n    return Ability(\n        name=\"cleave\",\n        range=1,\n        cost=cost,\n        target=TargetType.ENEMY,\n        effects=frozenset({Effect(EffectType.DAMAGE, dmg, duration)}),\n        aoe=1,\n        cast_time=2\n    )\n\nclass SwordsmanProfile(CharacterProfile):\n    def __init__(self) -> None:\n        self._max_hp = 110\n        self._max_ap = 16\n        self._ap_regen = 2\n        self._luck = 25\n        self._abilities: Tuple[Ability, ...] = (\n            # базовые\n            move_to_ability(range=1, cost=1),\n            melee_attack(dmg=25, cost=3),\n            sprint(extra_tiles=2, cost=2),\n            # уникальные мечника\n            activate_dodge(chance=50, duration=1, cost=1),\n            cleave(dmg=25, duration=0, cost=4),\n        )\n\n    @property\n    def max_hp(self) -> int:\n        return self._max_hp\n\n    @property\n    def max_ap(self) -> int:\n        return self._max_ap\n\n    @property\n    def ap_regen(self) -> int:\n        return self._ap_regen\n\n    @property\n    def abilities(self):\n        return self._abilities\n\n    @property\n    def luck(self):\n        return self._luck"
      }
    },
    "engine": {
      "__init__.py": {
        "path": "src/domain/engine/__init__.py",
        "content": ""
      },
      "ability_utils.py": {
        "path": "src/domain/engine/ability_utils.py",
        "content": "# src/domain/engine/ability_utils.py\n\nfrom typing import List\nfrom ..core.unit import HeroUnit\nfrom ..geometry.position import Position\n\n\n\ndef select_chain_targets(\n    center: Position,\n    state: \"GameState\",\n    max_targets: int = 3,\n    radius: int = 5\n) -> List[HeroUnit]:\n    \"\"\"\n    Возвращает до max_targets ближайших живых юнитов (кроме primary)\n    в пределах радиуса manhattan от center.\n    \"\"\"\n    units = [\n        u for u in state.units.values()\n        if u.is_alive() and u.pos != center and u.pos.distance(center) <= radius\n    ]\n    units.sort(key=lambda u: u.pos.distance(center))\n    return units[:max_targets]\n"
      },
      "applier.py": {
        "path": "src/domain/engine/applier.py",
        "content": "# src/domain/engine/applier.py\n\nimport random\nfrom typing import List\n\nfrom domain.engine.combat import calculate_damage\nfrom ..core.state import GameState\nfrom ..core.unit import HeroUnit\nfrom ..core.ability import Ability\nfrom ..core.effect import EffectType, Effect\n\nfrom ..analytics.stats import stats_tracker\nfrom ..geometry.position import Position\n\nfrom config.logger import RTS_Logger\n\nlogger = RTS_Logger()\n\n\ndef apply_ability(\n    state: GameState,\n    caster: HeroUnit,\n    ability: Ability,\n    target_pos: Position\n) -> None:\n    # зафиксировать факт использования\n    stats_tracker.record_use(caster.id, ability.name)\n    logger.log_lvl2(f\"Caster {caster.id} uses '{ability.name}' on {target_pos}\")\n\n    # соберём список целей\n    primary = state.get_unit_at(target_pos)\n    targets: List[HeroUnit] = [primary] if primary else []\n\n    if ability.aoe > 0:\n        for u in state.units.values():\n            if u is not primary and u.pos.distance(target_pos) <= ability.aoe:\n                targets.append(u)\n\n    # примение эффектов\n    for u in targets:\n        for eff in ability.effects:\n\n            blinds = [e for e in u.effects if e.type is EffectType.BLIND]\n            if blinds:\n                blind = blinds[0]\n                roll = random.uniform(0, 100)\n                logger.log_lvl2(f\"Unit {u.id} BLIND roll={roll:.2f} vs chance={blind.value}\")\n                if roll < blind.value:\n                    logger.log_lvl2(f\"Unit {u.id} evades '{ability.name}' due to BLIND\")\n                    continue\n\n            # 1) Урон — через calculate_damage (учёт crit/fumble, BUFF/DEBUFF на кастере)\n            if eff.type is EffectType.DAMAGE:\n                dmg = calculate_damage(caster, ability)\n                dealt = u.apply_damage(dmg)\n                enemy = (u.team != caster.team)\n                stats_tracker.record_damage(caster.id, ability.name, dealt, enemy)\n                logger.log_lvl3(f\"Unit {u.id} took {dealt} damage (rolled {dmg})\")\n\n            # 2) Лечение — как было\n            elif eff.type is EffectType.HEAL:\n                healed = u.apply_heal(eff.value)\n                stats_tracker.record_heal(caster.id, ability.name, healed)\n                logger.log_lvl3(f\"Unit {u.id} healed {healed}\")\n\n            # 3) Все остальные эффекты (BUFF, DEBUFF, SLOW_AP, AP_BOOST и т.д.) — навешиваем на цель\n            else:\n                u.add_effect(eff)\n                stats_tracker.record_effect(caster.id, ability.name, eff.type, eff.value)\n                logger.log_lvl3(f\"Unit {u.id} gains {eff.type.name} ({eff.value})\")\n"
      },
      "combat.py": {
        "path": "src/domain/engine/combat.py",
        "content": "# src/domain/core/combat.py\n\nfrom typing import Tuple, List\n\nfrom config.logger import RTS_Logger\nfrom domain.core.ability import Ability\nfrom ..core.effect import Effect, EffectType\nimport random\n\nlogger = RTS_Logger()\n\n\ndef calculate_damage(caster: 'HeroUnit', ability: Ability) -> int:\n    \"\"\"\n    Считает исходный урон ability + баффы на урон у кастера.\n    \"\"\"\n    # базовый урон из эффектов способности\n    base = sum(e.value for e in ability.effects if e.type is EffectType.DAMAGE)\n    # добавляем бонусы к урону из эффектов типа BUFF\n    for eff in caster.effects:\n        if eff.type is EffectType.BUFF:\n            base += eff.value\n        elif eff.type is EffectType.DEBUFF:\n            base -= eff.value\n\n    # luck-based crit / fumble\n    luck: int = caster.luck\n    crit_chance: float = min(100.0, getattr(ability, 'crit_base', 5.0) + luck * 0.2)\n    fumble_chance: float = max(0.0, getattr(ability, 'fumble_base', 2.0) - luck * 0.1)\n\n    roll = random.uniform(0, 100)\n    if roll < fumble_chance:\n        logger.log_lvl2(\n            f\"FUMBLE by unit {caster.id}: base={base}, roll={roll:.2f} < fumble_chance={fumble_chance:.2f}\"\n        )\n        return int(base * 0.5)\n    if roll < fumble_chance + crit_chance:\n        logger.log_lvl2(\n            f\"CRIT by unit {caster.id}: base={base}, roll={roll:.2f} < fumble_chance+crit_chance={fumble_chance+crit_chance:.2f}\"\n        )\n        return int(base * 1.5)\n    logger.log_lvl3(\n        f\"HIT by unit {caster.id}: base={base}, roll={roll:.2f} >= fumble_chance+crit_chance={fumble_chance+crit_chance:.2f}\"\n    )\n    return int(base)\n\n\ndef apply_damage_to_unit(unit: 'HeroUnit', amount: int) -> int:\n    \"\"\"\n    Наносит unit урон с учётом:\n      - DODGE: шанс увернуться\n      - щитов (SHIELD)\n    Возвращает фактически нанесённый урон.\n    \"\"\"\n    # 1) DODGE\n    dodge_effects = [e for e in unit.effects if e.type is EffectType.DODGE]\n    if dodge_effects:\n        dodge = dodge_effects[0]\n        roll = random.uniform(0, 100)\n        logger.log_lvl2(f\"Unit {unit.id} DODGE roll={roll:.2f} vs chance={dodge.value}\")\n        if roll < dodge.value:\n            # увернулся — эффект однократно расходуется\n            unit.effects.remove(dodge)\n            logger.log_lvl2(f\"Unit {unit.id} dodged the attack!\")\n            return 0\n\n    # 2) щиты\n    remaining = amount\n    shields: List[Effect] = [e for e in unit.effects if e.type is EffectType.SHIELD]\n    if shields:\n        shield = shields[0]\n        logger.log_lvl2(f\"Unit {unit.id} has SHIELD {shield.value}\")\n        absorb = min(shield.value, remaining)\n        unit.effects.remove(shield)\n        if shield.value - absorb > 0:\n            unit.effects.append(Effect(EffectType.SHIELD, shield.value - absorb, shield.duration))\n            logger.log_lvl2(f\"  Remaining SHIELD {shield.value - absorb}\")\n        remaining -= absorb\n        logger.log_lvl2(f\"  After shield absorb remaining={remaining}\")\n\n    # 3) наносим оставшийся урон\n    dealt = remaining\n    prev_hp = unit.hp\n    unit.hp = max(0, unit.hp - remaining)\n    logger.log_lvl2(f\"Unit {unit.id} HP {prev_hp}->{unit.hp}, dealt={dealt}\")\n    return dealt\n\ndef apply_heal_to_unit(unit: 'HeroUnit', amount: int) -> int:\n    \"\"\"\n    Восстанавливает unit здоровье, не превышая max_hp.\n    Возвращает фактически восстановленное значение.\n    \"\"\"\n    if not unit.is_alive():\n        return 0\n\n    before = unit.hp\n    unit.hp = min(unit.profile.max_hp, unit.hp + amount)\n    return unit.hp - before\n\n\ndef add_effect_to_unit(unit: 'HeroUnit', effect: Effect) -> None:\n    \"\"\"\n    Накладывает на unit указанный эффект (buff/debuff).\n    \"\"\"\n    if unit.is_alive():\n        unit.effects.append(effect)\n"
      },
      "engine.md": {
        "path": "src/domain/engine/engine.md",
        "content": "# 🧠 `domain.engine/` — Логика симуляции боя\n\nМодуль `domain.engine` содержит **ядро симуляции игрового процесса по тиковой модели**.  \nОн отвечает за:\n\n- прогресс тика (`event_tick`)\n- применение способностей (`apply_ability`)\n- расчет эффектов (`damage`, `heal`, `effects`)\n- выбор целей (`chain targeting`)\n- запись боевой статистики (`stats_tracker`)\n\n---\n\n## 🔁 `event_loop.py` — главный цикл симуляции\n\nФункция `event_tick(state, intents)`:\n\n1. **Обновляет эффекты** (уменьшает длительность).\n2. **Применяет регенерацию зоны** (regen_zone).\n3. **Восстанавливает AP**.\n4. **Выполняет действия юнитов**:\n   - если идет каст → продолжаем\n   - если пришел новый интент → прерываем и заменяем\n   - иначе продолжаем текущее (движение/ожидание)\n\n**Если способность завершается и содержит эффекты** — она передается в `apply_ability`.\n\n---\n\n## ✨ `applier.py` — применение способностей\n\nФункция `apply_ability(...)`:\n- фиксирует использование в `stats_tracker`\n- выбирает цели (учитывая AoE)\n- применяет каждый `Effect`:\n  - `DAMAGE` → `apply_damage_to_unit`\n  - `HEAL` → `apply_heal_to_unit`\n  - `BUFF/DEBUFF/SHIELD` → `add_effect_to_unit`\n\n---\n\n## 🔗 `ability_utils.py` — выбор целей\n\n- `select_chain_targets(...)` — для цепных заклинаний:\n  выбирает до N ближайших целей в радиусе от центра.\n\n---\n\n## 🧪 `combat.py` — примитивы урона/хила\n\n- `calculate_damage()` — учитывает все BUFF-эффекты.\n- `apply_damage_to_unit()` — урон с учетом щита.\n- `apply_heal_to_unit()` — хил до max_hp.\n- `add_effect_to_unit()` — навешивает эффект.\n\n---\n\n## 🧩 Взаимосвязи:\n\n- `event_loop` вызывает `apply_ability`\n- `apply_ability` вызывает `combat` и `stats`\n- Все работает с `GameState` и `HeroUnit`\n\n---\n\n## 💡 Пример использования:\n\n```python\nstate, executed, done = event_tick(state, intents)\n```\n\n---\n\n## 📌 Где логика НЕ живет:\n- Никаких проверок условий/AI — только исполнение.\n- Все проверки (LoS, range) должны быть сделаны до передачи `intent`."
      },
      "event_loop.py": {
        "path": "src/domain/engine/event_loop.py",
        "content": "# src/domain/engine/event_loop.py\n\nfrom typing import Dict, Optional\nfrom ..core.state import GameState\nfrom ..core.action import ActiveAction\nfrom ..core.effect import EffectType\nfrom ..core.ability import Ability\nfrom ..core.unit import HeroUnit\nfrom .applier import apply_ability\nfrom ..errors import DomainError\nfrom config.logger import RTS_Logger\n\nlogger = RTS_Logger(__name__)\n\ndef apply_effects(unit: HeroUnit, state: GameState) -> Optional[ActiveAction]:\n    \"\"\"\n    Проверяет эффекты на вражеских юнитах (например, TAUNT) и,\n    если нужно, возвращает новый ActiveAction, которым следует\n    заменить intent этого юнита.\n    \"\"\"\n    for other in state.units.values():\n        if other.team != unit.team and other.is_alive():\n            for eff in other.effects:\n                if eff.type is EffectType.TAUNT and other.pos.distance(unit.pos) <= eff.value:\n                    # вражеский юнит other таунтит этого unit\n                    melee = next((ab for ab in unit.profile.abilities if ab.name == \"melee_attack\"), None)\n                    if melee and unit.ap >= melee.cost and unit.pos.distance(other.pos) <= melee.range:\n                        logger.log_lvl2(f\"Unit {unit.id} is taunted by {other.id}: will melee_attack\")\n                        return ActiveAction(\n                            ability=melee,\n                            target=other.pos,\n                            target_unit_id=other.id,\n                            ticks_remaining=melee.cast_time,\n                            path=None,\n                            started=False\n                        )\n                    move = next((ab for ab in unit.profile.abilities if ab.name == \"move_to\"), None)\n                    if move:\n                        logger.log_lvl2(f\"Unit {unit.id} is taunted by {other.id}: will move_to\")\n                        return ActiveAction(\n                            ability=move,\n                            target=other.pos,\n                            target_unit_id=other.id,\n                            ticks_remaining=move.cast_time,\n                            path=None,\n                            started=False\n                        )\n    return None\n\ndef event_tick(\n    state: GameState,\n    action_intents: Dict[int, ActiveAction]\n) -> tuple[GameState, Dict[int, bool], bool]:\n    executed: Dict[int, bool] = {}\n    logger.log_lvl2(f\"=== Tick {state.tick} START ===\")\n    \n    # Шаг 0. Очистить completed_action, оставшееся после прошлого тика\n    for u in state.units.values():\n        u.completed_action = None\n\n    # 1) Aging status effects\n    for u in state.units.values():\n        if u.is_alive:\n            u.tick_effects()\n\n    # 2) Zone effects\n    state.board.apply_zone_effects(state)\n\n    # 3) AP regen\n    for u in state.units.values():\n        if u.is_alive():\n            prev = u.ap\n            u.apply_ap_regen()\n            logger.log_lvl3(f\"Unit {u.id} AP regen {prev}->{u.ap}\")\n\n    # 4) Build intents including effect overrides\n    intents = dict(action_intents)\n    for u in state.units.values():\n        if not u.is_alive():\n            continue\n        override = apply_effects(u, state)\n        if override:\n            intents[u.id] = override\n\n    # 5) STUN: skip any stunned unit\n    for u in state.units.values():\n        if not u.is_alive():\n            continue\n        if any(e.type is EffectType.STUN for e in u.effects):\n            logger.log_lvl2(f\"Unit {u.id} is stunned and skips its turn\")\n            intents.pop(u.id, None)\n\n    # 6) Execute actions\n    for u in state.units.values():\n        executed[u.id] = False\n        if not u.is_alive():\n            continue\n\n        # a) finish ongoing cast\n        act = u.current_action\n        if act and getattr(act, \"started\", False):\n            comp = u.advance_action(state)\n            if comp:\n                tgt = state.units[comp.target_unit_id].pos if comp.target_unit_id is not None else comp.target\n                apply_ability(state, u, comp.ability, tgt)\n                executed[u.id] = True\n            continue\n\n        # b) start or overridden intent\n        intent = intents.get(u.id)\n        if intent:\n            try:\n                u.start_action(intent.ability, intent.target, state, intent.target_unit_id)\n                executed[u.id] = True\n            except DomainError as e:\n                logger.log_lvl1(f\"Unit {u.id} intent failed: {e}\")\n            continue\n\n        # c) continue current_action\n        comp = u.advance_action(state)\n        if comp and (comp.ability.effects or comp.ability.aoe > 0):\n            tgt = state.units[comp.target_unit_id].pos if comp.target_unit_id is not None else comp.target\n            apply_ability(state, u, comp.ability, tgt)\n            executed[u.id] = True\n\n    state.tick += 1\n    logger.log_lvl2(f\"=== Tick {state.tick-1} END ===\")\n    return state, executed, state.is_game_over()\n"
      }
    },
    "factory": {
      "game_factory.py": {
        "path": "src/domain/factory/game_factory.py",
        "content": "# src/domain/factory/game_factory.py\n\nfrom typing import Dict, Set\nfrom ..core.state import GameState\nfrom ..core.board import Board\nfrom ..factory.unit_factory import create_heroes_for_setup\nfrom ..geometry.position import Position\nfrom ..core.unit import HeroUnit\nfrom ..constants import TeamId\nfrom config.logger import RTS_Logger\n\n\nlogger = RTS_Logger()\n\ndef build_new_game(\n    *,\n    tick: int = 0,\n    hero_setup: Dict[TeamId, list[\"HeroConfig\"]],\n    obstacles: Set[Position],\n    regen_zone: Set[Position],\n) -> GameState:\n    \"\"\"\n    Собирает новое состояние игры:\n      - hero_setup: описание юнитов на старте\n      - obstacles, regen_zone: параметры карты\n    \"\"\"\n    \n\n    # 1. Создаём всех юнитов\n    heroes: list[HeroUnit] = create_heroes_for_setup(hero_setup)\n    units: Dict[int, HeroUnit] = {u.id: u for u in heroes}\n\n    # 2. Создаём карту\n    board = Board(obstacles=obstacles, regen_zone=regen_zone)\n\n    # 3. Логгируем создание состояния игры\n    logger.log_lvl2(f\"GameState created: tick={tick}, units={len(units)}\")\n    for u in units.values():\n        logger.log_lvl3(\n            f\"Unit {u.id} | team={u.team} | pos={u.pos} | hp={u.hp}/{u.profile.max_hp} | ap={u.ap}/{u.profile.max_ap}\"\n        )\n\n    # 4. Возвращаем GameState\n    return GameState(tick=tick, units=units, board=board)\n\n"
      },
      "unit_factory.py": {
        "path": "src/domain/factory/unit_factory.py",
        "content": "# src/domain/factory/unit_factory.py\n\nfrom typing import Dict, List\n\nfrom config.config_loader import HeroConfig\nfrom ..constants import TeamId\nfrom ..geometry.position import Position\nfrom ..core.unit import HeroUnit\nfrom ..enums import UnitRole\n\nfrom ..heroes.swordsman_profile import SwordsmanProfile\nfrom ..heroes.defender_profile import DefenderProfile\nfrom ..heroes.archer_profile    import ArcherProfile\nfrom ..heroes.mage_dps_profile  import MageDpsProfile\nfrom ..heroes.mage_supp_profile import MageSuppProfile\nfrom ..heroes.assassin_profile import AssassinProfile\nfrom ..heroes.bard_profile import BardProfile\n\n# маппинг роли → класс профиля\n_PROFILE_MAP: Dict[UnitRole, type] = {\n    UnitRole.SWORDSMAN:    SwordsmanProfile,\n    UnitRole.SHIELD:   DefenderProfile,\n    UnitRole.ARCHER:   ArcherProfile,\n    UnitRole.MAGE_DPS: MageDpsProfile,\n    UnitRole.MAGE_SUPP: MageSuppProfile,\n    UnitRole.ASSASSIN: AssassinProfile,\n    UnitRole.BARD: BardProfile\n}\n\ndef create_heroes_for_setup(\n    hero_setup: Dict[TeamId, List[\"HeroConfig\"]]\n) -> List[HeroUnit]:\n    \"\"\"\n    Для каждого HeroConfig:\n      - берём роль\n      - инстанцируем соответствующий CharacterProfile\n      - создаём HeroUnit(id, role, team, pos, profile)\n    \"\"\"\n    units: List[HeroUnit] = []\n    uid = 1\n\n    for team, heroes in hero_setup.items():\n        for hc in heroes:\n            role = UnitRole[hc.role]\n            pos = Position(*hc.pos)\n            profile_cls = _PROFILE_MAP[role]\n            profile = profile_cls()  # Composition: единый HeroUnit + профиль\n            unit = HeroUnit(\n                id=uid,\n                role=role,\n                team=team,\n                pos=pos,\n                profile=profile\n            )\n            units.append(unit)\n            uid += 1\n\n    return units\n"
      }
    },
    "analytics": {
      "analytics.md": {
        "path": "src/domain/analytics/analytics.md",
        "content": "# 📊 Domain Analytics\n\nПапка `src/domain/analytics` отвечает за сбор и хранение статистики игры на уровне домена:\n- сколько раз каждый юнит использовал каждую способность;\n- сколько урона он нанёс врагам и союзникам;\n- сколько исцелил;\n- какие эффекты наложил и в каком количестве.\n\nВ этой папке находится единственный модуль:\n\n---\n\n## stats.py\n\n```python\nfrom dataclasses import dataclass, field\nfrom typing import Dict\nfrom ..core.effect import EffectType\n\n@dataclass\nclass AbilityStats:\n    uses: int = 0\n    damage_to_enemies: int = 0\n    damage_to_allies: int = 0\n    healing: int = 0\n    effects_applied: Dict[EffectType, int] = field(default_factory=dict)\n\n@dataclass\nclass UnitStats:\n    by_ability: Dict[str, AbilityStats] = field(default_factory=dict)\n\nclass StatsTracker:\n    \"\"\"\n    Собирает per-tick и итоговую статистику по каждому юниту:\n      - record_use       — фиксирует использование способности\n      - record_damage    — фиксирует сколько урона нанесено и кому (враг/союзник)\n      - record_heal      — фиксирует сколько исцелено\n      - record_effect    — фиксирует, сколько и каких эффектов наложено\n      - get_stats        — возвращает итоговую статистику по всем юнитам\n      - reset            — очищает накопленные данные\n    \"\"\"\n    def __init__(self):\n        self.units: Dict[int, UnitStats] = {}\n\n    def _get_ability_stats(self, caster_id: int, ability_name: str) -> AbilityStats:\n\n    def record_use(self, caster_id: int, ability_name: str) -> None:\n\n    def record_damage(self, caster_id: int, ability_name: str, amount: int, enemy: bool) -> None:\n\n    def record_heal(self, caster_id: int, ability_name: str, amount: int) -> None:\n    \n    def record_effect(self, caster_id: int, ability_name: str, eff_type: EffectType, amount: int) -> None:\n\n    def get_stats(self) -> Dict[int, UnitStats]:\n\n    def reset(self) -> None:\n        \n\n# глобальный трекер, доступный во всём домене\nstats_tracker = StatsTracker()\nКак это работает\nИнтеграция в домен\nВ функции apply_ability (в domain/engine/applier.py) после каждого применения способности вызываются методы stats_tracker.record_*, чтобы зафиксировать:\n\nфакт использования (record_use),\n\nпринесённый урон (record_damage),\n\nотхил (record_heal),\n\nнакладываемые эффекты (record_effect).\n\nСбор и хранение\nStatsTracker хранит в поле units словарь:\n\npython\n\n{\n  unit_id: UnitStats(by_ability={\n    \"fireball\": AbilityStats(...),\n    \"move_to\":  AbilityStats(...),\n    ...\n  }),\n  ...\n}\nПолучение результатов\nВ любой момент (например, после завершения всех тиков) можно вызвать:\n\npython\nCopy\nEdit\nfrom domain.analytics.stats import stats_tracker\nfinal_stats = stats_tracker.get_stats()\nи получить подробную разбивку по каждому юниту и каждой способности.\n\nСброс\nЕсли нужно начать новый матч или тест, вызываем stats_tracker.reset(), чтобы очистить все старые данные.\n\nПример использования\n\n# ... в начале игры\nstats_tracker.reset()\n\n# во время игры — всё происходит автоматически внутри apply_ability\n\n# в конце игры\nfor unit_id, u_stats in stats_tracker.get_stats().items():\n    print(f\"Юнит {unit_id}:\")\n    for ability_name, ab in u_stats.by_ability.items():\n        print(f\"  {ability_name}: использовано {ab.uses} раз, \"\n              f\"урон врагам={ab.damage_to_enemies}, урон союзникам={ab.damage_to_allies}, \"\n              f\"лечение={ab.healing}, эффекты={ab.effects_applied}\")\n\nДанный модуль позволяет аналитикам и разработчикам быстро получать метрики по балансу способностей и поведению юнитов без изменения основной логики симуляции."
      },
      "stats.py": {
        "path": "src/domain/analytics/stats.py",
        "content": "# src/domain/analytics/stats.py\n\nfrom dataclasses import dataclass, field\nfrom typing import Dict\nfrom ..core.effect import EffectType\n\n\n@dataclass\nclass AbilityStats:\n    uses: int = 0\n    damage_to_enemies: int = 0\n    damage_to_allies: int = 0\n    healing: int = 0\n    effects_applied: Dict[EffectType, int] = field(default_factory=dict)\n\n\n@dataclass\nclass UnitStats:\n    by_ability: Dict[str, AbilityStats] = field(default_factory=dict)\n\n\nclass StatsTracker:\n    \"\"\"\n    Собирает per-tick и итоговую статистику по каждому юниту:\n      - сколько раз использовал каждую способность,\n      - сколько урона/хила нанес по врагам/союзникам,\n      - сколько и каких эффектов наложил.\n    \"\"\"\n    def __init__(self):\n        self.units: Dict[int, UnitStats] = {}\n\n    def _get_ability_stats(self, caster_id: int, ability_name: str) -> AbilityStats:\n        unit_stats = self.units.setdefault(caster_id, UnitStats())\n        return unit_stats.by_ability.setdefault(ability_name, AbilityStats())\n\n    def record_use(self, caster_id: int, ability_name: str) -> None:\n        self._get_ability_stats(caster_id, ability_name).uses += 1\n\n    def record_damage(self, caster_id: int, ability_name: str, amount: int, enemy: bool) -> None:\n        ab = self._get_ability_stats(caster_id, ability_name)\n        if enemy:\n            ab.damage_to_enemies += amount\n        else:\n            ab.damage_to_allies += amount\n\n    def record_heal(self, caster_id: int, ability_name: str, amount: int) -> None:\n        self._get_ability_stats(caster_id, ability_name).healing += amount\n\n    def record_effect(self, caster_id: int, ability_name: str, eff_type: EffectType, amount: int) -> None:\n        ab = self._get_ability_stats(caster_id, ability_name)\n        ab.effects_applied[eff_type] = ab.effects_applied.get(eff_type, 0) + amount\n\n    def get_stats(self) -> Dict[int, UnitStats]:\n        return self.units\n    \n    def reset(self) -> None:\n        self.units: Dict[int, UnitStats] = {}\n\n\n# создать один глобальный трекер\nstats_tracker = StatsTracker()\n"
      }
    },
    "core": {
      "__init__.py": {
        "path": "src/domain/core/__init__.py",
        "content": ""
      },
      "ability.py": {
        "path": "src/domain/core/ability.py",
        "content": "# src/domain/core/ability.py\n\nfrom dataclasses import dataclass\nfrom typing import FrozenSet\nfrom ..enums import EffectType, TargetType\nfrom .effect import Effect\n\n@dataclass(frozen=True, slots=True)\nclass Ability:\n    \"\"\"\n    Описание способности:\n      - name       — уникальный идентификатор\n      - range      — максимальная дистанция\n      - cost       — стоимость AP\n      - target     — SELF/ENEMY/ALLY…\n      - effects    — полный набор Effect (value+duration)\n      - cast_time  — тиков на применение\n      - aoe        — радиус области (0=одноцелевая)\n      - bounces    — для цепочек\n      - bounce_mult— множитель силы для прыжков\n    \"\"\"\n    name: str\n    range: int\n    cost: int\n    target: TargetType\n\n    # now a set of full Effect objects\n    effects: FrozenSet[Effect]\n\n    crit_base: float = 5.0     # базовый шанс крита в %\n    fumble_base: float = 2.0   # базовый шанс провала в %\n\n    # timing & extras\n    cast_time: int = 1\n    aoe: int = 0\n    bounces: int = 0\n    bounce_mult: float = 1.0\n"
      },
      "action.py": {
        "path": "src/domain/core/action.py",
        "content": "# src/domain/core/action.py\n\nfrom dataclasses import dataclass, field\nfrom typing import Any, List, Optional\nfrom .ability import Ability\nfrom ..geometry.position import Position\n\n@dataclass\nclass ActiveAction:\n    \"\"\"\n    An in-progress action that may take multiple ticks.\n    \"\"\"\n    ability: Ability\n    target: Position\n    ticks_remaining: int\n    path: Optional[List[Position]] = field(default=None)\n    target_unit_id: Optional[int] = None \n    started: bool = False\n    \n\n    def tick(self) -> bool:\n        \"\"\"\n        Advance one tick; return True if action just completed.\n        \"\"\"\n        self.ticks_remaining -= 1\n        return self.ticks_remaining <= 0\n"
      },
      "board.py": {
        "path": "src/domain/core/board.py",
        "content": "# src/domain/core/board.py\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom typing import Set\n\nfrom ..geometry.position import Position\n\n@dataclass(slots=True)\nclass Board:\n    \"\"\"\n    Матрица препятствий и «зон» (реген/бафф):\n      - obstacles   клетки, по которым нельзя ходить и стрелять\n      - regen_zone  клетки, где каждый тик +1 HP\n    \"\"\"\n    obstacles: Set[Position] = field(default_factory=set)\n    regen_zone: Set[Position] = field(default_factory=set)\n\n    def is_blocked(self, pos: Position) -> bool:\n        return pos in self.obstacles\n\n    def is_line_blocked(self, a: Position, b: Position) -> bool:\n        # Простая Манхэттен-линия по X или Y\n        if a.x == b.x:\n            step = 1 if b.y > a.y else -1\n            for y in range(a.y + step, b.y, step):\n                if Position(a.x, y) in self.obstacles:\n                    return True\n        elif a.y == b.y:\n            step = 1 if b.x > a.x else -1\n            for x in range(a.x + step, b.x, step):\n                if Position(x, a.y) in self.obstacles:\n                    return True\n        return False\n\n    def apply_zone_effects(self, state: 'GameState') -> None:\n        \"\"\"Каждый тик в regen_zone: +1 HP живым юнитам.\"\"\"\n        for u in state.units.values():\n            if u.pos in self.regen_zone and u.is_alive():\n                u.hp = min(u.profile.max_hp, u.hp + 1)\n"
      },
      "core.md": {
        "path": "src/domain/core/core.md",
        "content": "# 🧩 Domain Core Overview\n\n**`src/domain/core/`** — фундаментальный слой доменной модели, отвечающий за представление всех ключевых сущностей игровой логики: способностей, эффектов, доски, состояния игры и активных действий.\n\n---\n\n## Модули и классы\n\n### 1. `ability.py` — **Способности (Abilities)**\n\n```python\n@dataclass(frozen=True, slots=True)\nclass Ability:\n    name: str                # Уникальный идентификатор (например, \"fireball\")\n    range: int               # Дальность применения\n    cost: int                # Стоимость в AP\n    target: TargetType       # Тип цели: SELF, ENEMY, ALLY и др.\n    effects: FrozenSet[Effect]  # Набор эффектов, которые накладывает абилка\n    cast_time: int = 1       # Сколько тиков длится применение\n    aoe: int = 0             # Радиус действия (0 — одноцелевая)\n    bounces: int = 0         # Количество \"прыжков\" (для цепных умений)\n    bounce_mult: float = 1.0 # Множитель силы прыжка\nНазначение:\nОписание полной информации о способности (например, \"melee_attack\", \"move_to\", \"fireball\"). Абилка содержит все параметры для симуляции применения.\n\n2. action.py — Активные действия (Active Actions)\npython\nCopy\nEdit\n@dataclass\nclass ActiveAction:\n    ability: Ability\n    target: Position\n    ticks_remaining: int\n    path: Optional[List[Position]] = None\n    target_unit_id: Optional[int] = None\n    started: bool = False\n\n    def tick(self) -> bool:\n        self.ticks_remaining -= 1\n        return self.ticks_remaining <= 0\nНазначение:\nХранит текущее \"происходящее\" действие юнита: какую способность он кастует, по какой цели, сколько тиков осталось, какой путь идёт (для движения), начато ли применение.\nИспользуется для поэтапного исполнения сложных действий (движение, длительные касты).\n\n3. board.py — Игровое поле (Board)\npython\nCopy\nEdit\n@dataclass(slots=True)\nclass Board:\n    obstacles: Set[Position] = field(default_factory=set)\n    regen_zone: Set[Position] = field(default_factory=set)\n\n    def is_blocked(self, pos: Position) -> bool\n    def is_line_blocked(self, a: Position, b: Position) -> bool\n    def apply_zone_effects(self, state: 'GameState') -> None\nНазначение:\nПредставляет карту уровня:\n\nobstacles — клетки-стены, по которым нельзя пройти/прострелить.\n\nregen_zone — клетки, на которых восстанавливается HP.\n\nМетоды для проверки, можно ли пройти/прострелить между двумя точками, и применения зональных эффектов.\n\n4. effect.py — Эффекты (Effects)\npython\nCopy\nEdit\n@dataclass(frozen=True, slots=True)\nclass Effect:\n    type: EffectType    # Тип эффекта (DAMAGE, HEAL, SHIELD и др.)\n    value: int          # Значение (сколько HP лечит/снимает, сила щита и др.)\n    duration: int       # Длительность (в тиках)\nНазначение:\nКласс для представления одного эффекта (урон, щит, замедление и др.), который накладывается абилкой на цель.\n\n5. state.py — Состояние игры (GameState)\npython\nCopy\nEdit\n@dataclass(slots=True)\nclass GameState:\n    tick: int\n    units: Dict[int, HeroUnit]\n    board: Board\n\n    def clear_temporary(self) -> None\n    def get_unit_at(self, pos)\n    def is_game_over(self) -> bool\nНазначение:\n\nПредставляет всю игровую \"картину\": кто жив, кто где стоит, какие препятствия.\n\nХранит все юниты (units) и игровую доску (board).\n\nМетоды для быстрого доступа к юниту по позиции и проверки конца игры.\n\nВзаимосвязи\nAbility используется в ActiveAction (какую способность кастует юнит).\n\nEffect хранится внутри Ability (что произойдёт при касте).\n\nBoard и GameState отвечают за состояние поля и объектов.\n\nGameState содержит все юниты (HeroUnit) и доску (Board).\n\nActiveAction (у юнита) — ключевой для симуляции механизм \"что сейчас делает юнит\".\n\nДля чего использовать эти классы?\nAbility — когда нужно определить, как работает та или иная способность.\n\nActiveAction — если требуется знать, что сейчас делает юнит и сколько времени осталось.\n\nBoard — для проверки, можно ли ходить/стрелять по клетке.\n\nEffect — чтобы навесить/снять эффекты с персонажа.\n\nGameState — основная точка для доступа к состоянию игры в любом тике.\n\nВсе эти классы не содержат логики исполнения (кроме методов доступа и простых операций) и образуют чистую, независимую доменную модель. Вся \"магия\" симуляции происходит в engine — эти классы лишь её описывают.\n\n# 📦 src/domain/core — Модель юнита и статы\n\n## Модуль `unit_stats.py`\nОпределяет базовые характеристики любого юнита (не игровое состояние, а \"паспорт\"):\n\n```python\n@dataclass(frozen=True, slots=True)\nclass UnitStats:\n    \"\"\"\n    Базовые характеристики юнита:\n      - hp_max       — максимальное здоровье\n      - move_range   — сколько клеток может пройти за 1 AP\n      - block_chance — шанс заблокировать часть урона (0-100%)\n      - max_ap       — сколько AP сбрасывается в начале хода\n    \"\"\"\n    hp_max: int\n    move_range: int = 1\n    block_chance: int = 0\n    max_ap: int = MAX_AP\nИспользуется в профиле героя, чтобы быстро и централизованно описывать все \"постоянные\" параметры юнита.\n\nМодуль unit.py\nЯдро модели игрового персонажа: HeroUnit.\n\nОсновные аспекты:\nХранит динамическое состояние юнита (HP, AP, позиция, эффекты, текущее действие).\n\nПоддерживает работу с \"боевыми\" операциями через combat-модуль.\n\nРеализует логику старта и исполнения текущего действия с автоповтором.\n\nАвтоматически заново ставит действие после исполнения (до override).\n\nРаботает с pathfinding для движения.\n\nИспользует декомпозицию: урон, лечение, эффекты — в combat.\n\npython\nCopy\nEdit\n@dataclass(slots=True)\nclass HeroUnit:\n    id: int\n    role: UnitRole\n    team: TeamId\n    pos: Position\n    profile: CharacterProfile\n    hp: int = field(init=False)\n    ap: int = field(init=False)\n    effects: list[Effect] = field(default_factory=list, init=False)\n    current_action: Optional[ActiveAction] = field(default=None, init=False)\n    ...\nКлючевые методы:\ntick_effects — уменьшает длительность эффектов, удаляя истёкшие.\n\napply_ap_regen — восстанавливает AP по профилю.\n\napply_damage/apply_heal/add_effect — быстрый доступ к боевым операциям (делегирует combat-модулю).\n\nstart_action — начинает новое действие (если не кастует что-то).\n\nadvance_action — реализует основной жизненный цикл: движение, касты, повтор.\n\nТипичные сценарии использования:\nUnitStats — когда надо получить/задать базовые параметры, не зависящие от состояния боя.\n\nHeroUnit — всегда при обращении к игровому юниту в GameState.\n\nОтличие:\nUnitStats — неизменяемый набор характеристик (\"профиль\" юнита, аналог D&D stat block).\n\nHeroUnit — динамическое, изменяемое состояние юнита на карте (HP, AP, эффекты, позиция, текущее действие).\n\nВажные замечания:\nБоевая логика максимально выведена в combat-модуль для разделения ответственности.\n\nВсе действия юнита (каст, движение, ожидание) должны идти только через advance_action.\n\ncurrent_action автоматически повторяется, пока не будет перезаписано новым интентом."
      },
      "effect.py": {
        "path": "src/domain/core/effect.py",
        "content": "from dataclasses import dataclass\nfrom ..enums import EffectType\n\n@dataclass(frozen=True, slots=True)\nclass Effect:\n    \"\"\"\n    Активный эффект на юните:\n      - type      - тип эффекта (SLOW_AP, SHIELD и т.д.)\n      - value     - величина (сколько AP снимает, размер щита…)\n      - duration  - сколько ещё ходов действует\n    \"\"\"\n    type: EffectType\n    value: int\n    duration: int\n"
      },
      "state.py": {
        "path": "src/domain/core/state.py",
        "content": "from dataclasses import dataclass\nfrom typing import Dict\nfrom .unit import HeroUnit\nfrom .board import Board\n\n\n@dataclass(slots=True)\nclass GameState:\n    \"\"\"\n    Состояние игры:\n      - tick           — номер тика\n      - units          — словарь id→HeroUnit\n      - board          — экземпляр Board\n    \"\"\"\n    tick: int\n    units: Dict[int, HeroUnit]\n    board: Board\n\n    def clear_temporary(self) -> None:\n        for u in self.units.values():\n            u.clear_queue()\n            u.tick_effects()\n\n    def get_unit_at(self, pos):\n        for u in self.units.values():\n            if u.pos == pos and u.is_alive():\n                return u\n        return None\n\n    def is_game_over(self) -> bool:\n        teams = {u.team for u in self.units.values() if u.is_alive()}\n        return len(teams) <= 1\n\n"
      },
      "stats.py": {
        "path": "src/domain/core/stats.py",
        "content": "from dataclasses import dataclass\nfrom ..constants import MAX_AP\n\n@dataclass(frozen=True, slots=True)\nclass UnitStats:\n    \"\"\"\n    Базовые характеристики юнита:\n      - hp_max       - максимальное здоровье\n      - move_range   - сколько клеток может пройти за 1 AP\n      - block_chance - шанс заблокировать часть урона (0-100%)\n      - max_ap       - сколько AP сбрасывается в начале хода\n    \"\"\"\n    hp_max: int\n    move_range: int = 1\n    block_chance: int = 0\n    max_ap: int = MAX_AP\n"
      },
      "unit.py": {
        "path": "src/domain/core/unit.py",
        "content": "# src/domain/core/unit.py\n\nfrom dataclasses import dataclass, field\nfrom typing import Optional, Iterable\n\nfrom domain.engine.combat import add_effect_to_unit, apply_damage_to_unit, apply_heal_to_unit, calculate_damage\nfrom domain.geometry.pathfinding import find_path\n\nfrom ..constants import TeamId\nfrom ..enums import EffectType, UnitRole\nfrom ..geometry.position import Position\nfrom .ability import Ability\nfrom .effect import Effect\nfrom ..heroes.profile import CharacterProfile\nfrom .action import ActiveAction\nfrom config.logger import RTS_Logger\n\n\nlogger = RTS_Logger()\n\n\n@dataclass(slots=True)\nclass HeroUnit:\n    id: int\n    role: UnitRole\n    team: TeamId\n    pos: Position\n\n    profile: CharacterProfile\n\n    hp: int =   field(init=False)\n    ap: int =   field(init=False)\n    luck: int = field(init=False)\n    effects: list[Effect] = field(default_factory=list, init=False)\n\n    # single in‐flight action\n    current_action: Optional[ActiveAction] = field(default=None, init=False)\n    # Новое поле: какая ability была реально завершена на последнем тике\n    completed_action: Optional[ActiveAction] = field(default=None, init=False)\n\n    def __post_init__(self):\n        self.hp     = self.profile.max_hp\n        self.ap     = self.profile.max_ap\n        self.luck   = self.profile.luck\n\n    def is_alive(self) -> bool:\n        return self.hp > 0\n\n    @property\n    def abilities(self) -> Iterable[Ability]:\n        return self.profile.abilities\n\n    @property\n    def luck(self) -> int:\n        return self.profile.luck\n    \n    def tick_effects(self) -> None:\n        remaining = []\n        for eff in self.effects:\n            new_duration = eff.duration - 1\n            if new_duration > 0:\n                # создаём новый Effect (copy with duration-1)\n                new_eff = Effect(eff.type, eff.value, new_duration)\n                remaining.append(new_eff)\n        self.effects = remaining\n\n    def apply_ap_regen(self) -> None:\n        \"\"\"\n        Regenerate AP taking into account SLOW_AP debuffs and AP_BOOST buffs.\n        \"\"\"\n        base_regen: int = self.profile.ap_regen\n        slow_amount: int = sum(e.value for e in self.effects if e.type is EffectType.SLOW_AP)\n        boost_amount: int = sum(e.value for e in self.effects if e.type is EffectType.AP_BOOST)\n\n        regen: int = max(0, base_regen - slow_amount + boost_amount)\n        self.ap = min(self.profile.max_ap, self.ap + regen)\n\n    # ─── combat shortcuts ──────────────────────────────────────────\n\n    def apply_damage(self, amount: int) -> int:\n        return apply_damage_to_unit(self, amount)\n\n    def apply_heal(self, amount: int) -> int:\n        return apply_heal_to_unit(self, amount)\n\n    def add_effect(self, effect: Effect) -> None:\n        add_effect_to_unit(self, effect)\n    \n    def calculate_damage(self, ability: Ability) -> int:\n        return calculate_damage(self, ability)\n    # ─── action management ──────────────────────────────────\n\n    def start_action(\n        self,\n        ability: Ability,\n        target: Optional[Position],\n        state: \"GameState\",\n        target_unit_id: Optional[int] = None\n    ) -> None:\n        \"\"\"\n        Begin a new action, even if one is in progress (unless it's casting).\n        \"\"\"\n        prev = self.current_action\n        if prev and getattr(prev, \"started\", False):\n            # if in the middle of a cast, don't override\n            raise RuntimeError(\"Cannot override a casting action\")\n        logger.log_lvl3(f\"[start_action] Unit {self.id} ⇒ '{ability.name}' @ {target or target_unit_id}\")\n        self.current_action = ActiveAction(\n            ability=ability,\n            target=target,\n            target_unit_id=target_unit_id,\n            ticks_remaining=ability.cast_time,\n            path=None,\n            started=False\n        )\n\n    def advance_action(self, state: \"GameState\") -> Optional[ActiveAction]:\n        \"\"\"\n        Execute the current_action one tick:\n          1) If casting already started → tick down\n          2) Else if it's a movement ability → walk/sprint along path (no stepping onto occupied cells)\n          3) Else if in range & have AP → begin cast\n          4) Else if out of range & have AP → step closer\n          5) Else wait.\n        After an action completes, *re-queues* it until overridden.\n        Returns the completed ActiveAction once, else None.\n        \"\"\"\n        act = self.current_action\n        if not act:\n            return None\n\n        ab = act.ability\n        name = ab.name.lower()\n\n        # determine current target position\n        if act.target_unit_id is not None:\n            tgt_u = state.units.get(act.target_unit_id)\n            if not tgt_u or not tgt_u.is_alive():\n                self.current_action = None\n                return None\n            tgt_pos = tgt_u.pos\n        else:\n            tgt_pos = act.target\n\n        # 1) ongoing cast?\n        if getattr(act, \"started\", False):\n            done = act.tick()\n            if done:\n                self.completed_action = act\n                logger.log_lvl2(f\"Unit {self.id} finished cast '{ab.name}'\")\n                completed = act\n                self.current_action = ActiveAction(\n                    ability=ab,\n                    target=act.target,\n                    target_unit_id=act.target_unit_id,\n                    ticks_remaining=ab.cast_time,\n                    path=None,\n                    started=False\n                )\n                return completed\n            return None\n\n        # 2) movement abilities\n        if name in (\"move_to\", \"sprint\"):\n            if act.path is None:\n                act.path = find_path(self.pos, tgt_pos, state)\n            if not act.path:\n                return None\n\n            step_len = ab.range\n            moved = 0\n            while moved < step_len and self.ap > 0 and act.path:\n                next_pos = act.path[0]\n                occupant = state.get_unit_at(next_pos)\n                if occupant and occupant.is_alive() and occupant.id != self.id:\n                    logger.log_lvl2(f\"Unit {self.id} movement blocked at {next_pos} by unit {occupant.id}\")\n                    break\n                self.pos = act.path.pop(0)\n                self.ap -= 1\n                moved += 1\n\n            if not act.path or self.pos == tgt_pos:\n                logger.log_lvl2(f\"Unit {self.id} reached move target {tgt_pos}\")\n                completed = act\n                self.current_action = ActiveAction(\n                    ability=ab,\n                    target=act.target,\n                    target_unit_id=act.target_unit_id,\n                    ticks_remaining=ab.cast_time,\n                    path=None,\n                    started=False\n                )\n                return completed\n            return None\n\n        # 3) can start cast?\n        if self.ap >= ab.cost and (name == \"sprint\" or self.pos.distance(tgt_pos) <= ab.range):\n            self.ap -= ab.cost\n            act.started = True\n            done = act.tick()\n            if done:\n                self.completed_action = act\n                logger.log_lvl2(f\"Unit {self.id} instant '{ab.name}'\")\n                completed = act\n                self.current_action = ActiveAction(\n                    ability=ab,\n                    target=act.target,\n                    target_unit_id=act.target_unit_id,\n                    ticks_remaining=ab.cast_time,\n                    path=None,\n                    started=False\n                )\n                return completed\n            return None\n\n        # 4) step closer if out of range & have AP\n        if self.ap > 0 and self.pos.distance(tgt_pos) > ab.range:\n            path = find_path(self.pos, tgt_pos, state)\n            if path:\n                next_pos = path[0]\n                occupant = state.get_unit_at(next_pos)\n                if not (occupant and occupant.is_alive() and occupant.id != self.id):\n                    self.pos = next_pos\n                    self.ap -= 1\n            return None\n\n        # 5) no AP → wait\n        return None\n"
      }
    },
    "geometry": {
      "README.md": {
        "path": "src/domain/geometry/README.md",
        "content": ""
      },
      "__init__.py": {
        "path": "src/domain/geometry/__init__.py",
        "content": ""
      },
      "pathfinding.py": {
        "path": "src/domain/geometry/pathfinding.py",
        "content": "# src/domain/geometry/pathfinding.py\n\nfrom collections import deque\nfrom typing import List, Dict\n\nfrom ..geometry.position import Position\nfrom config.logger import RTS_Logger\n\nlogger = RTS_Logger()\n\n\nDIRECTIONS_8 = [\n    (1, 0), (-1, 0), (0, 1), (0, -1),\n    (1, 1), (1, -1), (-1, 1), (-1, -1)\n]\n\ndef find_path(start: Position, goal: Position, state: \"GameState\") -> List[Position]:\n    \"\"\"\n    BFS: возвращает список позиций от start (не включая) до goal (включая),\n    обходя препятствия и занятые клетки.\n    Если путь не найден — возвращает [].\n    \"\"\"\n    logger.log_lvl3(f\"[find_path] start={start}, goal={goal}\")\n    if start == goal:\n        logger.log_lvl3(\"[find_path] start == goal, empty path.\")\n        return []\n\n    visited = {start}\n    prev: Dict[Position, Position] = {}\n    q = deque([start])\n\n    while q:\n        cur = q.popleft()\n        for dx, dy in DIRECTIONS_8:\n            nxt = Position(cur.x + dx, cur.y + dy)\n            if not nxt.in_bounds():\n                continue\n            if state.board.is_blocked(nxt):\n                continue\n            occ = state.get_unit_at(nxt)\n            if occ and nxt != goal:\n                continue\n            if nxt in visited:\n                continue\n            # (MVP: можно пропустить угловую проверку)\n            visited.add(nxt)\n            prev[nxt] = cur\n            if nxt == goal:\n                path = [goal]\n                while path[-1] != start:\n                    path.append(prev[path[-1]])\n                return list(reversed(path))[1:]\n            q.append(nxt)\n            \n    logger.log_lvl2(f\"[find_path] No path found from {start} to {goal}\")\n    return []\n"
      },
      "position.py": {
        "path": "src/domain/geometry/position.py",
        "content": "from dataclasses import dataclass\nfrom ..constants import BOARD_SIZE\n\n@dataclass(frozen=True, slots=True)\nclass Position:\n    x: int; y: int\n    def distance(self, other) -> int:\n        if isinstance(other, Position):\n            return max(abs(self.x - other.x), abs(self.y - other.y))\n        if hasattr(other, \"pos\"):\n            return max(abs(self.x - other.pos.x), abs(self.y - other.pos.y))\n        else:\n            raise TypeError(f\"manhattan: expected Position or object with .pos, got {type(other)}\")\n    \n    def in_bounds(self) -> bool:\n        return 0 <= self.x < BOARD_SIZE and 0 <= self.y < BOARD_SIZE\n"
      }
    }
  },
  "interfaces": {
    "cli.py": {
      "path": "src/interfaces/cli.py",
      "content": "import argparse\nimport sys\nfrom config.cli_config import cli_settings\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(prog=\"turnshock\")\n    parser.add_argument(\n        \"--renderer\",\n        choices=[\"text\", \"pygame\"],\n        default=\"pygame\",\n        help=\"Выбор режима вывода: текстовый CLI или Pygame\"\n    )\n    args = parser.parse_args()\n\n    if args.renderer == \"pygame\":\n        from ui.pygame.app import PyGameApp\n\n        PyGameApp(\n            width=cli_settings.screen_w,\n            height=cli_settings.screen_h,\n            cell=cli_settings.cell_size,\n        ).run()\n    else:\n        print(\"Текстовый режим пока не реализован.\")\n        sys.exit(0)\n\nif __name__ == \"__main__\":\n    main()"
    }
  }
}